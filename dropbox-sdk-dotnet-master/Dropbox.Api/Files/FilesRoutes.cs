// <auto-generated>
// Auto-generated by StoneAPI, do not modify.
// </auto-generated>

namespace Dropbox.Api.Files.Routes
{
    using sys = System;
    using io = System.IO;
    using col = System.Collections.Generic;
    using t = System.Threading.Tasks;
    using enc = Dropbox.Api.Stone;

    /// <summary>
    /// <para>The routes for the <see cref="N:Dropbox.Api.Files"/> namespace</para>
    /// </summary>
    public class FilesRoutes
    {
        /// <summary>
        /// <para>Initializes a new instance of the <see cref="FilesRoutes" /> class.</para>
        /// </summary>
        /// <param name="transport">The transport to use</param>
        internal FilesRoutes(enc.ITransport transport)
        {
            this.Transport = transport;
        }

        /// <summary>
        /// <para>Gets the transport used for these routes</para>
        /// </summary>
        internal enc.ITransport Transport { get; private set; }

        /// <summary>
        /// <para>Returns the metadata for a file or folder. This is an alpha endpoint
        /// compatible with the properties API.</para>
        /// <para>Note: Metadata for the root folder is unsupported.</para>
        /// </summary>
        /// <param name="alphaGetMetadataArg">The request parameters</param>
        /// <returns>The task that represents the asynchronous send operation. The TResult
        /// parameter contains the response from the server.</returns>
        /// <exception cref="Dropbox.Api.ApiException{TError}">Thrown if there is an error
        /// processing the request; This will contain a <see
        /// cref="AlphaGetMetadataError"/>.</exception>
        public t.Task<Metadata> AlphaGetMetadataAsync(AlphaGetMetadataArg alphaGetMetadataArg)
        {
            return this.Transport.SendRpcRequestAsync<AlphaGetMetadataArg, Metadata, AlphaGetMetadataError>(alphaGetMetadataArg, "api", "/files/alpha/get_metadata", Dropbox.Api.Files.AlphaGetMetadataArg.Encoder, Dropbox.Api.Files.Metadata.Decoder, Dropbox.Api.Files.AlphaGetMetadataError.Decoder);
        }

        /// <summary>
        /// <para>Begins an asynchronous send to the alpha get metadata route.</para>
        /// </summary>
        /// <param name="alphaGetMetadataArg">The request parameters.</param>
        /// <param name="callback">The method to be called when the asynchronous send is
        /// completed.</param>
        /// <param name="state">A user provided object that distinguished this send from other
        /// send requests.</param>
        /// <returns>An object that represents the asynchronous send request.</returns>
        public sys.IAsyncResult BeginAlphaGetMetadata(AlphaGetMetadataArg alphaGetMetadataArg, sys.AsyncCallback callback, object state = null)
        {
            var task = this.AlphaGetMetadataAsync(alphaGetMetadataArg);

            return enc.Util.ToApm(task, callback, state);
        }

        /// <summary>
        /// <para>Returns the metadata for a file or folder. This is an alpha endpoint
        /// compatible with the properties API.</para>
        /// <para>Note: Metadata for the root folder is unsupported.</para>
        /// </summary>
        /// <param name="path">The path of a file or folder on Dropbox.</param>
        /// <param name="includeMediaInfo">If true, <see
        /// cref="Dropbox.Api.Files.FileMetadata.MediaInfo" /> is set for photo and
        /// video.</param>
        /// <param name="includeDeleted">If true, <see cref="DeletedMetadata" /> will be
        /// returned for deleted file or folder, otherwise <see
        /// cref="Dropbox.Api.Files.LookupError.NotFound" /> will be returned.</param>
        /// <param name="includeHasExplicitSharedMembers">If true, the results will include a
        /// flag for each file indicating whether or not  that file has any explicit
        /// members.</param>
        /// <param name="includePropertyTemplates">If true, <see
        /// cref="Dropbox.Api.Files.FileMetadata.PropertyGroups" /> is set for files with
        /// custom properties.</param>
        /// <returns>The task that represents the asynchronous send operation. The TResult
        /// parameter contains the response from the server.</returns>
        /// <exception cref="Dropbox.Api.ApiException{TError}">Thrown if there is an error
        /// processing the request; This will contain a <see
        /// cref="AlphaGetMetadataError"/>.</exception>
        public t.Task<Metadata> AlphaGetMetadataAsync(string path,
                                                      bool includeMediaInfo = false,
                                                      bool includeDeleted = false,
                                                      bool includeHasExplicitSharedMembers = false,
                                                      col.IEnumerable<string> includePropertyTemplates = null)
        {
            var alphaGetMetadataArg = new AlphaGetMetadataArg(path,
                                                              includeMediaInfo,
                                                              includeDeleted,
                                                              includeHasExplicitSharedMembers,
                                                              includePropertyTemplates);

            return this.AlphaGetMetadataAsync(alphaGetMetadataArg);
        }

        /// <summary>
        /// <para>Begins an asynchronous send to the alpha get metadata route.</para>
        /// </summary>
        /// <param name="path">The path of a file or folder on Dropbox.</param>
        /// <param name="includeMediaInfo">If true, <see
        /// cref="Dropbox.Api.Files.FileMetadata.MediaInfo" /> is set for photo and
        /// video.</param>
        /// <param name="includeDeleted">If true, <see cref="DeletedMetadata" /> will be
        /// returned for deleted file or folder, otherwise <see
        /// cref="Dropbox.Api.Files.LookupError.NotFound" /> will be returned.</param>
        /// <param name="includeHasExplicitSharedMembers">If true, the results will include a
        /// flag for each file indicating whether or not  that file has any explicit
        /// members.</param>
        /// <param name="includePropertyTemplates">If true, <see
        /// cref="Dropbox.Api.Files.FileMetadata.PropertyGroups" /> is set for files with
        /// custom properties.</param>
        /// <param name="callback">The method to be called when the asynchronous send is
        /// completed.</param>
        /// <param name="callbackState">A user provided object that distinguished this send
        /// from other send requests.</param>
        /// <returns>An object that represents the asynchronous send request.</returns>
        public sys.IAsyncResult BeginAlphaGetMetadata(string path,
                                                      bool includeMediaInfo = false,
                                                      bool includeDeleted = false,
                                                      bool includeHasExplicitSharedMembers = false,
                                                      col.IEnumerable<string> includePropertyTemplates = null,
                                                      sys.AsyncCallback callback = null,
                                                      object callbackState = null)
        {
            var alphaGetMetadataArg = new AlphaGetMetadataArg(path,
                                                              includeMediaInfo,
                                                              includeDeleted,
                                                              includeHasExplicitSharedMembers,
                                                              includePropertyTemplates);

            return this.BeginAlphaGetMetadata(alphaGetMetadataArg, callback, callbackState);
        }

        /// <summary>
        /// <para>Waits for the pending asynchronous send to the alpha get metadata route to
        /// complete</para>
        /// </summary>
        /// <param name="asyncResult">The reference to the pending asynchronous send
        /// request</param>
        /// <returns>The response to the send request</returns>
        /// <exception cref="Dropbox.Api.ApiException{TError}">Thrown if there is an error
        /// processing the request; This will contain a <see
        /// cref="AlphaGetMetadataError"/>.</exception>
        public Metadata EndAlphaGetMetadata(sys.IAsyncResult asyncResult)
        {
            var task = asyncResult as t.Task<Metadata>;
            if (task == null)
            {
                throw new sys.InvalidOperationException();
            }

            return task.Result;
        }

        /// <summary>
        /// <para>Create a new file with the contents provided in the request. Note that this
        /// endpoint is part of the properties API alpha and is slightly different from <see
        /// cref="Dropbox.Api.Files.Routes.FilesRoutes.UploadAsync" />.</para>
        /// <para>Do not use this to upload a file larger than 150 MB. Instead, create an
        /// upload session with <see
        /// cref="Dropbox.Api.Files.Routes.FilesRoutes.UploadSessionStartAsync" />.</para>
        /// </summary>
        /// <param name="commitInfoWithProperties">The request parameters</param>
        /// <param name="body">The content to upload.</param>
        /// <returns>The task that represents the asynchronous send operation. The TResult
        /// parameter contains the response from the server.</returns>
        /// <exception cref="Dropbox.Api.ApiException{TError}">Thrown if there is an error
        /// processing the request; This will contain a <see
        /// cref="UploadErrorWithProperties"/>.</exception>
        public t.Task<FileMetadata> AlphaUploadAsync(CommitInfoWithProperties commitInfoWithProperties, io.Stream body)
        {
            return this.Transport.SendUploadRequestAsync<CommitInfoWithProperties, FileMetadata, UploadErrorWithProperties>(commitInfoWithProperties, body, "content", "/files/alpha/upload", Dropbox.Api.Files.CommitInfoWithProperties.Encoder, Dropbox.Api.Files.FileMetadata.Decoder, Dropbox.Api.Files.UploadErrorWithProperties.Decoder);
        }

        /// <summary>
        /// <para>Begins an asynchronous send to the alpha upload route.</para>
        /// </summary>
        /// <param name="commitInfoWithProperties">The request parameters.</param>
        /// <param name="body">The content to upload.</param>
        /// <param name="callback">The method to be called when the asynchronous send is
        /// completed.</param>
        /// <param name="state">A user provided object that distinguished this send from other
        /// send requests.</param>
        /// <returns>An object that represents the asynchronous send request.</returns>
        public sys.IAsyncResult BeginAlphaUpload(CommitInfoWithProperties commitInfoWithProperties, io.Stream body, sys.AsyncCallback callback, object state = null)
        {
            var task = this.AlphaUploadAsync(commitInfoWithProperties, body);

            return enc.Util.ToApm(task, callback, state);
        }

        /// <summary>
        /// <para>Create a new file with the contents provided in the request. Note that this
        /// endpoint is part of the properties API alpha and is slightly different from <see
        /// cref="Dropbox.Api.Files.Routes.FilesRoutes.UploadAsync" />.</para>
        /// <para>Do not use this to upload a file larger than 150 MB. Instead, create an
        /// upload session with <see
        /// cref="Dropbox.Api.Files.Routes.FilesRoutes.UploadSessionStartAsync" />.</para>
        /// </summary>
        /// <param name="path">Path in the user's Dropbox to save the file.</param>
        /// <param name="mode">Selects what to do if the file already exists.</param>
        /// <param name="autorename">If there's a conflict, as determined by <paramref
        /// name="mode" />, have the Dropbox server try to autorename the file to avoid
        /// conflict.</param>
        /// <param name="clientModified">The value to store as the <paramref
        /// name="clientModified" /> timestamp. Dropbox automatically records the time at which
        /// the file was written to the Dropbox servers. It can also record an additional
        /// timestamp, provided by Dropbox desktop clients, mobile clients, and API apps of
        /// when the file was actually created or modified.</param>
        /// <param name="mute">Normally, users are made aware of any file modifications in
        /// their Dropbox account via notifications in the client software. If <c>true</c>,
        /// this tells the clients that this modification shouldn't result in a user
        /// notification.</param>
        /// <param name="propertyGroups">List of custom properties to add to file.</param>
        /// <param name="body">The document to upload</param>
        /// <returns>The task that represents the asynchronous send operation. The TResult
        /// parameter contains the response from the server.</returns>
        /// <exception cref="Dropbox.Api.ApiException{TError}">Thrown if there is an error
        /// processing the request; This will contain a <see
        /// cref="UploadErrorWithProperties"/>.</exception>
        public t.Task<FileMetadata> AlphaUploadAsync(string path,
                                                     WriteMode mode = null,
                                                     bool autorename = false,
                                                     sys.DateTime? clientModified = null,
                                                     bool mute = false,
                                                     col.IEnumerable<Dropbox.Api.Properties.PropertyGroup> propertyGroups = null,
                                                     io.Stream body = null)
        {
            var commitInfoWithProperties = new CommitInfoWithProperties(path,
                                                                        mode,
                                                                        autorename,
                                                                        clientModified,
                                                                        mute,
                                                                        propertyGroups);

            return this.AlphaUploadAsync(commitInfoWithProperties, body);
        }

        /// <summary>
        /// <para>Begins an asynchronous send to the alpha upload route.</para>
        /// </summary>
        /// <param name="path">Path in the user's Dropbox to save the file.</param>
        /// <param name="mode">Selects what to do if the file already exists.</param>
        /// <param name="autorename">If there's a conflict, as determined by <paramref
        /// name="mode" />, have the Dropbox server try to autorename the file to avoid
        /// conflict.</param>
        /// <param name="clientModified">The value to store as the <paramref
        /// name="clientModified" /> timestamp. Dropbox automatically records the time at which
        /// the file was written to the Dropbox servers. It can also record an additional
        /// timestamp, provided by Dropbox desktop clients, mobile clients, and API apps of
        /// when the file was actually created or modified.</param>
        /// <param name="mute">Normally, users are made aware of any file modifications in
        /// their Dropbox account via notifications in the client software. If <c>true</c>,
        /// this tells the clients that this modification shouldn't result in a user
        /// notification.</param>
        /// <param name="propertyGroups">List of custom properties to add to file.</param>
        /// <param name="body">The document to upload</param>
        /// <param name="callback">The method to be called when the asynchronous send is
        /// completed.</param>
        /// <param name="callbackState">A user provided object that distinguished this send
        /// from other send requests.</param>
        /// <returns>An object that represents the asynchronous send request.</returns>
        public sys.IAsyncResult BeginAlphaUpload(string path,
                                                 WriteMode mode = null,
                                                 bool autorename = false,
                                                 sys.DateTime? clientModified = null,
                                                 bool mute = false,
                                                 col.IEnumerable<Dropbox.Api.Properties.PropertyGroup> propertyGroups = null,
                                                 io.Stream body = null,
                                                 sys.AsyncCallback callback = null,
                                                 object callbackState = null)
        {
            var commitInfoWithProperties = new CommitInfoWithProperties(path,
                                                                        mode,
                                                                        autorename,
                                                                        clientModified,
                                                                        mute,
                                                                        propertyGroups);

            return this.BeginAlphaUpload(commitInfoWithProperties, body, callback, callbackState);
        }

        /// <summary>
        /// <para>Waits for the pending asynchronous send to the alpha upload route to
        /// complete</para>
        /// </summary>
        /// <param name="asyncResult">The reference to the pending asynchronous send
        /// request</param>
        /// <returns>The response to the send request</returns>
        /// <exception cref="Dropbox.Api.ApiException{TError}">Thrown if there is an error
        /// processing the request; This will contain a <see
        /// cref="UploadErrorWithProperties"/>.</exception>
        public FileMetadata EndAlphaUpload(sys.IAsyncResult asyncResult)
        {
            var task = asyncResult as t.Task<FileMetadata>;
            if (task == null)
            {
                throw new sys.InvalidOperationException();
            }

            return task.Result;
        }

        /// <summary>
        /// <para>Copy a file or folder to a different location in the user's Dropbox.</para>
        /// <para>If the source path is a folder all its contents will be copied.</para>
        /// </summary>
        /// <param name="relocationArg">The request parameters</param>
        /// <returns>The task that represents the asynchronous send operation. The TResult
        /// parameter contains the response from the server.</returns>
        /// <exception cref="Dropbox.Api.ApiException{TError}">Thrown if there is an error
        /// processing the request; This will contain a <see
        /// cref="RelocationError"/>.</exception>
        public t.Task<Metadata> CopyAsync(RelocationArg relocationArg)
        {
            return this.Transport.SendRpcRequestAsync<RelocationArg, Metadata, RelocationError>(relocationArg, "api", "/files/copy", Dropbox.Api.Files.RelocationArg.Encoder, Dropbox.Api.Files.Metadata.Decoder, Dropbox.Api.Files.RelocationError.Decoder);
        }

        /// <summary>
        /// <para>Begins an asynchronous send to the copy route.</para>
        /// </summary>
        /// <param name="relocationArg">The request parameters.</param>
        /// <param name="callback">The method to be called when the asynchronous send is
        /// completed.</param>
        /// <param name="state">A user provided object that distinguished this send from other
        /// send requests.</param>
        /// <returns>An object that represents the asynchronous send request.</returns>
        public sys.IAsyncResult BeginCopy(RelocationArg relocationArg, sys.AsyncCallback callback, object state = null)
        {
            var task = this.CopyAsync(relocationArg);

            return enc.Util.ToApm(task, callback, state);
        }

        /// <summary>
        /// <para>Copy a file or folder to a different location in the user's Dropbox.</para>
        /// <para>If the source path is a folder all its contents will be copied.</para>
        /// </summary>
        /// <param name="fromPath">Path in the user's Dropbox to be copied or moved.</param>
        /// <param name="toPath">Path in the user's Dropbox that is the destination.</param>
        /// <returns>The task that represents the asynchronous send operation. The TResult
        /// parameter contains the response from the server.</returns>
        /// <exception cref="Dropbox.Api.ApiException{TError}">Thrown if there is an error
        /// processing the request; This will contain a <see
        /// cref="RelocationError"/>.</exception>
        public t.Task<Metadata> CopyAsync(string fromPath,
                                          string toPath)
        {
            var relocationArg = new RelocationArg(fromPath,
                                                  toPath);

            return this.CopyAsync(relocationArg);
        }

        /// <summary>
        /// <para>Begins an asynchronous send to the copy route.</para>
        /// </summary>
        /// <param name="fromPath">Path in the user's Dropbox to be copied or moved.</param>
        /// <param name="toPath">Path in the user's Dropbox that is the destination.</param>
        /// <param name="callback">The method to be called when the asynchronous send is
        /// completed.</param>
        /// <param name="callbackState">A user provided object that distinguished this send
        /// from other send requests.</param>
        /// <returns>An object that represents the asynchronous send request.</returns>
        public sys.IAsyncResult BeginCopy(string fromPath,
                                          string toPath,
                                          sys.AsyncCallback callback,
                                          object callbackState = null)
        {
            var relocationArg = new RelocationArg(fromPath,
                                                  toPath);

            return this.BeginCopy(relocationArg, callback, callbackState);
        }

        /// <summary>
        /// <para>Waits for the pending asynchronous send to the copy route to complete</para>
        /// </summary>
        /// <param name="asyncResult">The reference to the pending asynchronous send
        /// request</param>
        /// <returns>The response to the send request</returns>
        /// <exception cref="Dropbox.Api.ApiException{TError}">Thrown if there is an error
        /// processing the request; This will contain a <see
        /// cref="RelocationError"/>.</exception>
        public Metadata EndCopy(sys.IAsyncResult asyncResult)
        {
            var task = asyncResult as t.Task<Metadata>;
            if (task == null)
            {
                throw new sys.InvalidOperationException();
            }

            return task.Result;
        }

        /// <summary>
        /// <para>Get a copy reference to a file or folder. This reference string can be used
        /// to save that file or folder to another user's Dropbox by passing it to <see
        /// cref="Dropbox.Api.Files.Routes.FilesRoutes.CopyReferenceSaveAsync" />.</para>
        /// </summary>
        /// <param name="getCopyReferenceArg">The request parameters</param>
        /// <returns>The task that represents the asynchronous send operation. The TResult
        /// parameter contains the response from the server.</returns>
        /// <exception cref="Dropbox.Api.ApiException{TError}">Thrown if there is an error
        /// processing the request; This will contain a <see
        /// cref="GetCopyReferenceError"/>.</exception>
        public t.Task<GetCopyReferenceResult> CopyReferenceGetAsync(GetCopyReferenceArg getCopyReferenceArg)
        {
            return this.Transport.SendRpcRequestAsync<GetCopyReferenceArg, GetCopyReferenceResult, GetCopyReferenceError>(getCopyReferenceArg, "api", "/files/copy_reference/get", Dropbox.Api.Files.GetCopyReferenceArg.Encoder, Dropbox.Api.Files.GetCopyReferenceResult.Decoder, Dropbox.Api.Files.GetCopyReferenceError.Decoder);
        }

        /// <summary>
        /// <para>Begins an asynchronous send to the copy reference get route.</para>
        /// </summary>
        /// <param name="getCopyReferenceArg">The request parameters.</param>
        /// <param name="callback">The method to be called when the asynchronous send is
        /// completed.</param>
        /// <param name="state">A user provided object that distinguished this send from other
        /// send requests.</param>
        /// <returns>An object that represents the asynchronous send request.</returns>
        public sys.IAsyncResult BeginCopyReferenceGet(GetCopyReferenceArg getCopyReferenceArg, sys.AsyncCallback callback, object state = null)
        {
            var task = this.CopyReferenceGetAsync(getCopyReferenceArg);

            return enc.Util.ToApm(task, callback, state);
        }

        /// <summary>
        /// <para>Get a copy reference to a file or folder. This reference string can be used
        /// to save that file or folder to another user's Dropbox by passing it to <see
        /// cref="Dropbox.Api.Files.Routes.FilesRoutes.CopyReferenceSaveAsync" />.</para>
        /// </summary>
        /// <param name="path">The path to the file or folder you want to get a copy reference
        /// to.</param>
        /// <returns>The task that represents the asynchronous send operation. The TResult
        /// parameter contains the response from the server.</returns>
        /// <exception cref="Dropbox.Api.ApiException{TError}">Thrown if there is an error
        /// processing the request; This will contain a <see
        /// cref="GetCopyReferenceError"/>.</exception>
        public t.Task<GetCopyReferenceResult> CopyReferenceGetAsync(string path)
        {
            var getCopyReferenceArg = new GetCopyReferenceArg(path);

            return this.CopyReferenceGetAsync(getCopyReferenceArg);
        }

        /// <summary>
        /// <para>Begins an asynchronous send to the copy reference get route.</para>
        /// </summary>
        /// <param name="path">The path to the file or folder you want to get a copy reference
        /// to.</param>
        /// <param name="callback">The method to be called when the asynchronous send is
        /// completed.</param>
        /// <param name="callbackState">A user provided object that distinguished this send
        /// from other send requests.</param>
        /// <returns>An object that represents the asynchronous send request.</returns>
        public sys.IAsyncResult BeginCopyReferenceGet(string path,
                                                      sys.AsyncCallback callback,
                                                      object callbackState = null)
        {
            var getCopyReferenceArg = new GetCopyReferenceArg(path);

            return this.BeginCopyReferenceGet(getCopyReferenceArg, callback, callbackState);
        }

        /// <summary>
        /// <para>Waits for the pending asynchronous send to the copy reference get route to
        /// complete</para>
        /// </summary>
        /// <param name="asyncResult">The reference to the pending asynchronous send
        /// request</param>
        /// <returns>The response to the send request</returns>
        /// <exception cref="Dropbox.Api.ApiException{TError}">Thrown if there is an error
        /// processing the request; This will contain a <see
        /// cref="GetCopyReferenceError"/>.</exception>
        public GetCopyReferenceResult EndCopyReferenceGet(sys.IAsyncResult asyncResult)
        {
            var task = asyncResult as t.Task<GetCopyReferenceResult>;
            if (task == null)
            {
                throw new sys.InvalidOperationException();
            }

            return task.Result;
        }

        /// <summary>
        /// <para>Save a copy reference returned by <see
        /// cref="Dropbox.Api.Files.Routes.FilesRoutes.CopyReferenceGetAsync" /> to the user's
        /// Dropbox.</para>
        /// </summary>
        /// <param name="saveCopyReferenceArg">The request parameters</param>
        /// <returns>The task that represents the asynchronous send operation. The TResult
        /// parameter contains the response from the server.</returns>
        /// <exception cref="Dropbox.Api.ApiException{TError}">Thrown if there is an error
        /// processing the request; This will contain a <see
        /// cref="SaveCopyReferenceError"/>.</exception>
        public t.Task<SaveCopyReferenceResult> CopyReferenceSaveAsync(SaveCopyReferenceArg saveCopyReferenceArg)
        {
            return this.Transport.SendRpcRequestAsync<SaveCopyReferenceArg, SaveCopyReferenceResult, SaveCopyReferenceError>(saveCopyReferenceArg, "api", "/files/copy_reference/save", Dropbox.Api.Files.SaveCopyReferenceArg.Encoder, Dropbox.Api.Files.SaveCopyReferenceResult.Decoder, Dropbox.Api.Files.SaveCopyReferenceError.Decoder);
        }

        /// <summary>
        /// <para>Begins an asynchronous send to the copy reference save route.</para>
        /// </summary>
        /// <param name="saveCopyReferenceArg">The request parameters.</param>
        /// <param name="callback">The method to be called when the asynchronous send is
        /// completed.</param>
        /// <param name="state">A user provided object that distinguished this send from other
        /// send requests.</param>
        /// <returns>An object that represents the asynchronous send request.</returns>
        public sys.IAsyncResult BeginCopyReferenceSave(SaveCopyReferenceArg saveCopyReferenceArg, sys.AsyncCallback callback, object state = null)
        {
            var task = this.CopyReferenceSaveAsync(saveCopyReferenceArg);

            return enc.Util.ToApm(task, callback, state);
        }

        /// <summary>
        /// <para>Save a copy reference returned by <see
        /// cref="Dropbox.Api.Files.Routes.FilesRoutes.CopyReferenceGetAsync" /> to the user's
        /// Dropbox.</para>
        /// </summary>
        /// <param name="copyReference">A copy reference returned by <see
        /// cref="Dropbox.Api.Files.Routes.FilesRoutes.CopyReferenceGetAsync" />.</param>
        /// <param name="path">Path in the user's Dropbox that is the destination.</param>
        /// <returns>The task that represents the asynchronous send operation. The TResult
        /// parameter contains the response from the server.</returns>
        /// <exception cref="Dropbox.Api.ApiException{TError}">Thrown if there is an error
        /// processing the request; This will contain a <see
        /// cref="SaveCopyReferenceError"/>.</exception>
        public t.Task<SaveCopyReferenceResult> CopyReferenceSaveAsync(string copyReference,
                                                                      string path)
        {
            var saveCopyReferenceArg = new SaveCopyReferenceArg(copyReference,
                                                                path);

            return this.CopyReferenceSaveAsync(saveCopyReferenceArg);
        }

        /// <summary>
        /// <para>Begins an asynchronous send to the copy reference save route.</para>
        /// </summary>
        /// <param name="copyReference">A copy reference returned by <see
        /// cref="Dropbox.Api.Files.Routes.FilesRoutes.CopyReferenceGetAsync" />.</param>
        /// <param name="path">Path in the user's Dropbox that is the destination.</param>
        /// <param name="callback">The method to be called when the asynchronous send is
        /// completed.</param>
        /// <param name="callbackState">A user provided object that distinguished this send
        /// from other send requests.</param>
        /// <returns>An object that represents the asynchronous send request.</returns>
        public sys.IAsyncResult BeginCopyReferenceSave(string copyReference,
                                                       string path,
                                                       sys.AsyncCallback callback,
                                                       object callbackState = null)
        {
            var saveCopyReferenceArg = new SaveCopyReferenceArg(copyReference,
                                                                path);

            return this.BeginCopyReferenceSave(saveCopyReferenceArg, callback, callbackState);
        }

        /// <summary>
        /// <para>Waits for the pending asynchronous send to the copy reference save route to
        /// complete</para>
        /// </summary>
        /// <param name="asyncResult">The reference to the pending asynchronous send
        /// request</param>
        /// <returns>The response to the send request</returns>
        /// <exception cref="Dropbox.Api.ApiException{TError}">Thrown if there is an error
        /// processing the request; This will contain a <see
        /// cref="SaveCopyReferenceError"/>.</exception>
        public SaveCopyReferenceResult EndCopyReferenceSave(sys.IAsyncResult asyncResult)
        {
            var task = asyncResult as t.Task<SaveCopyReferenceResult>;
            if (task == null)
            {
                throw new sys.InvalidOperationException();
            }

            return task.Result;
        }

        /// <summary>
        /// <para>Create a folder at a given path.</para>
        /// </summary>
        /// <param name="createFolderArg">The request parameters</param>
        /// <returns>The task that represents the asynchronous send operation. The TResult
        /// parameter contains the response from the server.</returns>
        /// <exception cref="Dropbox.Api.ApiException{TError}">Thrown if there is an error
        /// processing the request; This will contain a <see
        /// cref="CreateFolderError"/>.</exception>
        public t.Task<FolderMetadata> CreateFolderAsync(CreateFolderArg createFolderArg)
        {
            return this.Transport.SendRpcRequestAsync<CreateFolderArg, FolderMetadata, CreateFolderError>(createFolderArg, "api", "/files/create_folder", Dropbox.Api.Files.CreateFolderArg.Encoder, Dropbox.Api.Files.FolderMetadata.Decoder, Dropbox.Api.Files.CreateFolderError.Decoder);
        }

        /// <summary>
        /// <para>Begins an asynchronous send to the create folder route.</para>
        /// </summary>
        /// <param name="createFolderArg">The request parameters.</param>
        /// <param name="callback">The method to be called when the asynchronous send is
        /// completed.</param>
        /// <param name="state">A user provided object that distinguished this send from other
        /// send requests.</param>
        /// <returns>An object that represents the asynchronous send request.</returns>
        public sys.IAsyncResult BeginCreateFolder(CreateFolderArg createFolderArg, sys.AsyncCallback callback, object state = null)
        {
            var task = this.CreateFolderAsync(createFolderArg);

            return enc.Util.ToApm(task, callback, state);
        }

        /// <summary>
        /// <para>Create a folder at a given path.</para>
        /// </summary>
        /// <param name="path">Path in the user's Dropbox to create.</param>
        /// <returns>The task that represents the asynchronous send operation. The TResult
        /// parameter contains the response from the server.</returns>
        /// <exception cref="Dropbox.Api.ApiException{TError}">Thrown if there is an error
        /// processing the request; This will contain a <see
        /// cref="CreateFolderError"/>.</exception>
        public t.Task<FolderMetadata> CreateFolderAsync(string path)
        {
            var createFolderArg = new CreateFolderArg(path);

            return this.CreateFolderAsync(createFolderArg);
        }

        /// <summary>
        /// <para>Begins an asynchronous send to the create folder route.</para>
        /// </summary>
        /// <param name="path">Path in the user's Dropbox to create.</param>
        /// <param name="callback">The method to be called when the asynchronous send is
        /// completed.</param>
        /// <param name="callbackState">A user provided object that distinguished this send
        /// from other send requests.</param>
        /// <returns>An object that represents the asynchronous send request.</returns>
        public sys.IAsyncResult BeginCreateFolder(string path,
                                                  sys.AsyncCallback callback,
                                                  object callbackState = null)
        {
            var createFolderArg = new CreateFolderArg(path);

            return this.BeginCreateFolder(createFolderArg, callback, callbackState);
        }

        /// <summary>
        /// <para>Waits for the pending asynchronous send to the create folder route to
        /// complete</para>
        /// </summary>
        /// <param name="asyncResult">The reference to the pending asynchronous send
        /// request</param>
        /// <returns>The response to the send request</returns>
        /// <exception cref="Dropbox.Api.ApiException{TError}">Thrown if there is an error
        /// processing the request; This will contain a <see
        /// cref="CreateFolderError"/>.</exception>
        public FolderMetadata EndCreateFolder(sys.IAsyncResult asyncResult)
        {
            var task = asyncResult as t.Task<FolderMetadata>;
            if (task == null)
            {
                throw new sys.InvalidOperationException();
            }

            return task.Result;
        }

        /// <summary>
        /// <para>Delete the file or folder at a given path.</para>
        /// <para>If the path is a folder, all its contents will be deleted too.</para>
        /// <para>A successful response indicates that the file or folder was deleted. The
        /// returned metadata will be the corresponding <see cref="FileMetadata" /> or <see
        /// cref="FolderMetadata" /> for the item at time of deletion, and not a <see
        /// cref="DeletedMetadata" /> object.</para>
        /// </summary>
        /// <param name="deleteArg">The request parameters</param>
        /// <returns>The task that represents the asynchronous send operation. The TResult
        /// parameter contains the response from the server.</returns>
        /// <exception cref="Dropbox.Api.ApiException{TError}">Thrown if there is an error
        /// processing the request; This will contain a <see cref="DeleteError"/>.</exception>
        public t.Task<Metadata> DeleteAsync(DeleteArg deleteArg)
        {
            return this.Transport.SendRpcRequestAsync<DeleteArg, Metadata, DeleteError>(deleteArg, "api", "/files/delete", Dropbox.Api.Files.DeleteArg.Encoder, Dropbox.Api.Files.Metadata.Decoder, Dropbox.Api.Files.DeleteError.Decoder);
        }

        /// <summary>
        /// <para>Begins an asynchronous send to the delete route.</para>
        /// </summary>
        /// <param name="deleteArg">The request parameters.</param>
        /// <param name="callback">The method to be called when the asynchronous send is
        /// completed.</param>
        /// <param name="state">A user provided object that distinguished this send from other
        /// send requests.</param>
        /// <returns>An object that represents the asynchronous send request.</returns>
        public sys.IAsyncResult BeginDelete(DeleteArg deleteArg, sys.AsyncCallback callback, object state = null)
        {
            var task = this.DeleteAsync(deleteArg);

            return enc.Util.ToApm(task, callback, state);
        }

        /// <summary>
        /// <para>Delete the file or folder at a given path.</para>
        /// <para>If the path is a folder, all its contents will be deleted too.</para>
        /// <para>A successful response indicates that the file or folder was deleted. The
        /// returned metadata will be the corresponding <see cref="FileMetadata" /> or <see
        /// cref="FolderMetadata" /> for the item at time of deletion, and not a <see
        /// cref="DeletedMetadata" /> object.</para>
        /// </summary>
        /// <param name="path">Path in the user's Dropbox to delete.</param>
        /// <returns>The task that represents the asynchronous send operation. The TResult
        /// parameter contains the response from the server.</returns>
        /// <exception cref="Dropbox.Api.ApiException{TError}">Thrown if there is an error
        /// processing the request; This will contain a <see cref="DeleteError"/>.</exception>
        public t.Task<Metadata> DeleteAsync(string path)
        {
            var deleteArg = new DeleteArg(path);

            return this.DeleteAsync(deleteArg);
        }

        /// <summary>
        /// <para>Begins an asynchronous send to the delete route.</para>
        /// </summary>
        /// <param name="path">Path in the user's Dropbox to delete.</param>
        /// <param name="callback">The method to be called when the asynchronous send is
        /// completed.</param>
        /// <param name="callbackState">A user provided object that distinguished this send
        /// from other send requests.</param>
        /// <returns>An object that represents the asynchronous send request.</returns>
        public sys.IAsyncResult BeginDelete(string path,
                                            sys.AsyncCallback callback,
                                            object callbackState = null)
        {
            var deleteArg = new DeleteArg(path);

            return this.BeginDelete(deleteArg, callback, callbackState);
        }

        /// <summary>
        /// <para>Waits for the pending asynchronous send to the delete route to
        /// complete</para>
        /// </summary>
        /// <param name="asyncResult">The reference to the pending asynchronous send
        /// request</param>
        /// <returns>The response to the send request</returns>
        /// <exception cref="Dropbox.Api.ApiException{TError}">Thrown if there is an error
        /// processing the request; This will contain a <see cref="DeleteError"/>.</exception>
        public Metadata EndDelete(sys.IAsyncResult asyncResult)
        {
            var task = asyncResult as t.Task<Metadata>;
            if (task == null)
            {
                throw new sys.InvalidOperationException();
            }

            return task.Result;
        }

        /// <summary>
        /// <para>Download a file from a user's Dropbox.</para>
        /// </summary>
        /// <param name="downloadArg">The request parameters</param>
        /// <returns>The task that represents the asynchronous send operation. The TResult
        /// parameter contains the response from the server.</returns>
        /// <exception cref="Dropbox.Api.ApiException{TError}">Thrown if there is an error
        /// processing the request; This will contain a <see
        /// cref="DownloadError"/>.</exception>
        public t.Task<enc.IDownloadResponse<FileMetadata>> DownloadAsync(DownloadArg downloadArg)
        {
            return this.Transport.SendDownloadRequestAsync<DownloadArg, FileMetadata, DownloadError>(downloadArg, "content", "/files/download", Dropbox.Api.Files.DownloadArg.Encoder, Dropbox.Api.Files.FileMetadata.Decoder, Dropbox.Api.Files.DownloadError.Decoder);
        }

        /// <summary>
        /// <para>Begins an asynchronous send to the download route.</para>
        /// </summary>
        /// <param name="downloadArg">The request parameters.</param>
        /// <param name="callback">The method to be called when the asynchronous send is
        /// completed.</param>
        /// <param name="state">A user provided object that distinguished this send from other
        /// send requests.</param>
        /// <returns>An object that represents the asynchronous send request.</returns>
        public sys.IAsyncResult BeginDownload(DownloadArg downloadArg, sys.AsyncCallback callback, object state = null)
        {
            var task = this.DownloadAsync(downloadArg);

            return enc.Util.ToApm(task, callback, state);
        }

        /// <summary>
        /// <para>Download a file from a user's Dropbox.</para>
        /// </summary>
        /// <param name="path">The path of the file to download.</param>
        /// <param name="rev">Deprecated. Please specify revision in <paramref name="path" />
        /// instead</param>
        /// <returns>The task that represents the asynchronous send operation. The TResult
        /// parameter contains the response from the server.</returns>
        /// <exception cref="Dropbox.Api.ApiException{TError}">Thrown if there is an error
        /// processing the request; This will contain a <see
        /// cref="DownloadError"/>.</exception>
        public t.Task<enc.IDownloadResponse<FileMetadata>> DownloadAsync(string path,
                                                                         string rev = null)
        {
            var downloadArg = new DownloadArg(path,
                                              rev);

            return this.DownloadAsync(downloadArg);
        }

        /// <summary>
        /// <para>Begins an asynchronous send to the download route.</para>
        /// </summary>
        /// <param name="path">The path of the file to download.</param>
        /// <param name="rev">Deprecated. Please specify revision in <paramref name="path" />
        /// instead</param>
        /// <param name="callback">The method to be called when the asynchronous send is
        /// completed.</param>
        /// <param name="callbackState">A user provided object that distinguished this send
        /// from other send requests.</param>
        /// <returns>An object that represents the asynchronous send request.</returns>
        public sys.IAsyncResult BeginDownload(string path,
                                              string rev = null,
                                              sys.AsyncCallback callback = null,
                                              object callbackState = null)
        {
            var downloadArg = new DownloadArg(path,
                                              rev);

            return this.BeginDownload(downloadArg, callback, callbackState);
        }

        /// <summary>
        /// <para>Waits for the pending asynchronous send to the download route to
        /// complete</para>
        /// </summary>
        /// <param name="asyncResult">The reference to the pending asynchronous send
        /// request</param>
        /// <returns>The response to the send request</returns>
        /// <exception cref="Dropbox.Api.ApiException{TError}">Thrown if there is an error
        /// processing the request; This will contain a <see
        /// cref="DownloadError"/>.</exception>
        public enc.IDownloadResponse<FileMetadata> EndDownload(sys.IAsyncResult asyncResult)
        {
            var task = asyncResult as t.Task<enc.IDownloadResponse<FileMetadata>>;
            if (task == null)
            {
                throw new sys.InvalidOperationException();
            }

            return task.Result;
        }

        /// <summary>
        /// <para>Returns the metadata for a file or folder.</para>
        /// <para>Note: Metadata for the root folder is unsupported.</para>
        /// </summary>
        /// <param name="getMetadataArg">The request parameters</param>
        /// <returns>The task that represents the asynchronous send operation. The TResult
        /// parameter contains the response from the server.</returns>
        /// <exception cref="Dropbox.Api.ApiException{TError}">Thrown if there is an error
        /// processing the request; This will contain a <see
        /// cref="GetMetadataError"/>.</exception>
        public t.Task<Metadata> GetMetadataAsync(GetMetadataArg getMetadataArg)
        {
            return this.Transport.SendRpcRequestAsync<GetMetadataArg, Metadata, GetMetadataError>(getMetadataArg, "api", "/files/get_metadata", Dropbox.Api.Files.GetMetadataArg.Encoder, Dropbox.Api.Files.Metadata.Decoder, Dropbox.Api.Files.GetMetadataError.Decoder);
        }

        /// <summary>
        /// <para>Begins an asynchronous send to the get metadata route.</para>
        /// </summary>
        /// <param name="getMetadataArg">The request parameters.</param>
        /// <param name="callback">The method to be called when the asynchronous send is
        /// completed.</param>
        /// <param name="state">A user provided object that distinguished this send from other
        /// send requests.</param>
        /// <returns>An object that represents the asynchronous send request.</returns>
        public sys.IAsyncResult BeginGetMetadata(GetMetadataArg getMetadataArg, sys.AsyncCallback callback, object state = null)
        {
            var task = this.GetMetadataAsync(getMetadataArg);

            return enc.Util.ToApm(task, callback, state);
        }

        /// <summary>
        /// <para>Returns the metadata for a file or folder.</para>
        /// <para>Note: Metadata for the root folder is unsupported.</para>
        /// </summary>
        /// <param name="path">The path of a file or folder on Dropbox.</param>
        /// <param name="includeMediaInfo">If true, <see
        /// cref="Dropbox.Api.Files.FileMetadata.MediaInfo" /> is set for photo and
        /// video.</param>
        /// <param name="includeDeleted">If true, <see cref="DeletedMetadata" /> will be
        /// returned for deleted file or folder, otherwise <see
        /// cref="Dropbox.Api.Files.LookupError.NotFound" /> will be returned.</param>
        /// <param name="includeHasExplicitSharedMembers">If true, the results will include a
        /// flag for each file indicating whether or not  that file has any explicit
        /// members.</param>
        /// <returns>The task that represents the asynchronous send operation. The TResult
        /// parameter contains the response from the server.</returns>
        /// <exception cref="Dropbox.Api.ApiException{TError}">Thrown if there is an error
        /// processing the request; This will contain a <see
        /// cref="GetMetadataError"/>.</exception>
        public t.Task<Metadata> GetMetadataAsync(string path,
                                                 bool includeMediaInfo = false,
                                                 bool includeDeleted = false,
                                                 bool includeHasExplicitSharedMembers = false)
        {
            var getMetadataArg = new GetMetadataArg(path,
                                                    includeMediaInfo,
                                                    includeDeleted,
                                                    includeHasExplicitSharedMembers);

            return this.GetMetadataAsync(getMetadataArg);
        }

        /// <summary>
        /// <para>Begins an asynchronous send to the get metadata route.</para>
        /// </summary>
        /// <param name="path">The path of a file or folder on Dropbox.</param>
        /// <param name="includeMediaInfo">If true, <see
        /// cref="Dropbox.Api.Files.FileMetadata.MediaInfo" /> is set for photo and
        /// video.</param>
        /// <param name="includeDeleted">If true, <see cref="DeletedMetadata" /> will be
        /// returned for deleted file or folder, otherwise <see
        /// cref="Dropbox.Api.Files.LookupError.NotFound" /> will be returned.</param>
        /// <param name="includeHasExplicitSharedMembers">If true, the results will include a
        /// flag for each file indicating whether or not  that file has any explicit
        /// members.</param>
        /// <param name="callback">The method to be called when the asynchronous send is
        /// completed.</param>
        /// <param name="callbackState">A user provided object that distinguished this send
        /// from other send requests.</param>
        /// <returns>An object that represents the asynchronous send request.</returns>
        public sys.IAsyncResult BeginGetMetadata(string path,
                                                 bool includeMediaInfo = false,
                                                 bool includeDeleted = false,
                                                 bool includeHasExplicitSharedMembers = false,
                                                 sys.AsyncCallback callback = null,
                                                 object callbackState = null)
        {
            var getMetadataArg = new GetMetadataArg(path,
                                                    includeMediaInfo,
                                                    includeDeleted,
                                                    includeHasExplicitSharedMembers);

            return this.BeginGetMetadata(getMetadataArg, callback, callbackState);
        }

        /// <summary>
        /// <para>Waits for the pending asynchronous send to the get metadata route to
        /// complete</para>
        /// </summary>
        /// <param name="asyncResult">The reference to the pending asynchronous send
        /// request</param>
        /// <returns>The response to the send request</returns>
        /// <exception cref="Dropbox.Api.ApiException{TError}">Thrown if there is an error
        /// processing the request; This will contain a <see
        /// cref="GetMetadataError"/>.</exception>
        public Metadata EndGetMetadata(sys.IAsyncResult asyncResult)
        {
            var task = asyncResult as t.Task<Metadata>;
            if (task == null)
            {
                throw new sys.InvalidOperationException();
            }

            return task.Result;
        }

        /// <summary>
        /// <para>Get a preview for a file. Currently previews are only generated for the files
        /// with  the following extensions: .doc, .docx, .docm, .ppt, .pps, .ppsx, .ppsm,
        /// .pptx, .pptm,  .xls, .xlsx, .xlsm, .rtf</para>
        /// </summary>
        /// <param name="previewArg">The request parameters</param>
        /// <returns>The task that represents the asynchronous send operation. The TResult
        /// parameter contains the response from the server.</returns>
        /// <exception cref="Dropbox.Api.ApiException{TError}">Thrown if there is an error
        /// processing the request; This will contain a <see cref="PreviewError"/>.</exception>
        public t.Task<enc.IDownloadResponse<FileMetadata>> GetPreviewAsync(PreviewArg previewArg)
        {
            return this.Transport.SendDownloadRequestAsync<PreviewArg, FileMetadata, PreviewError>(previewArg, "content", "/files/get_preview", Dropbox.Api.Files.PreviewArg.Encoder, Dropbox.Api.Files.FileMetadata.Decoder, Dropbox.Api.Files.PreviewError.Decoder);
        }

        /// <summary>
        /// <para>Begins an asynchronous send to the get preview route.</para>
        /// </summary>
        /// <param name="previewArg">The request parameters.</param>
        /// <param name="callback">The method to be called when the asynchronous send is
        /// completed.</param>
        /// <param name="state">A user provided object that distinguished this send from other
        /// send requests.</param>
        /// <returns>An object that represents the asynchronous send request.</returns>
        public sys.IAsyncResult BeginGetPreview(PreviewArg previewArg, sys.AsyncCallback callback, object state = null)
        {
            var task = this.GetPreviewAsync(previewArg);

            return enc.Util.ToApm(task, callback, state);
        }

        /// <summary>
        /// <para>Get a preview for a file. Currently previews are only generated for the files
        /// with  the following extensions: .doc, .docx, .docm, .ppt, .pps, .ppsx, .ppsm,
        /// .pptx, .pptm,  .xls, .xlsx, .xlsm, .rtf</para>
        /// </summary>
        /// <param name="path">The path of the file to preview.</param>
        /// <param name="rev">Deprecated. Please specify revision in <paramref name="path" />
        /// instead</param>
        /// <returns>The task that represents the asynchronous send operation. The TResult
        /// parameter contains the response from the server.</returns>
        /// <exception cref="Dropbox.Api.ApiException{TError}">Thrown if there is an error
        /// processing the request; This will contain a <see cref="PreviewError"/>.</exception>
        public t.Task<enc.IDownloadResponse<FileMetadata>> GetPreviewAsync(string path,
                                                                           string rev = null)
        {
            var previewArg = new PreviewArg(path,
                                            rev);

            return this.GetPreviewAsync(previewArg);
        }

        /// <summary>
        /// <para>Begins an asynchronous send to the get preview route.</para>
        /// </summary>
        /// <param name="path">The path of the file to preview.</param>
        /// <param name="rev">Deprecated. Please specify revision in <paramref name="path" />
        /// instead</param>
        /// <param name="callback">The method to be called when the asynchronous send is
        /// completed.</param>
        /// <param name="callbackState">A user provided object that distinguished this send
        /// from other send requests.</param>
        /// <returns>An object that represents the asynchronous send request.</returns>
        public sys.IAsyncResult BeginGetPreview(string path,
                                                string rev = null,
                                                sys.AsyncCallback callback = null,
                                                object callbackState = null)
        {
            var previewArg = new PreviewArg(path,
                                            rev);

            return this.BeginGetPreview(previewArg, callback, callbackState);
        }

        /// <summary>
        /// <para>Waits for the pending asynchronous send to the get preview route to
        /// complete</para>
        /// </summary>
        /// <param name="asyncResult">The reference to the pending asynchronous send
        /// request</param>
        /// <returns>The response to the send request</returns>
        /// <exception cref="Dropbox.Api.ApiException{TError}">Thrown if there is an error
        /// processing the request; This will contain a <see cref="PreviewError"/>.</exception>
        public enc.IDownloadResponse<FileMetadata> EndGetPreview(sys.IAsyncResult asyncResult)
        {
            var task = asyncResult as t.Task<enc.IDownloadResponse<FileMetadata>>;
            if (task == null)
            {
                throw new sys.InvalidOperationException();
            }

            return task.Result;
        }

        /// <summary>
        /// <para>Get a temporary link to stream content of a file. This link will expire in
        /// four hours and afterwards you will get 410 Gone. Content-Type of the link is
        /// determined automatically by the file's mime type.</para>
        /// </summary>
        /// <param name="getTemporaryLinkArg">The request parameters</param>
        /// <returns>The task that represents the asynchronous send operation. The TResult
        /// parameter contains the response from the server.</returns>
        /// <exception cref="Dropbox.Api.ApiException{TError}">Thrown if there is an error
        /// processing the request; This will contain a <see
        /// cref="GetTemporaryLinkError"/>.</exception>
        public t.Task<GetTemporaryLinkResult> GetTemporaryLinkAsync(GetTemporaryLinkArg getTemporaryLinkArg)
        {
            return this.Transport.SendRpcRequestAsync<GetTemporaryLinkArg, GetTemporaryLinkResult, GetTemporaryLinkError>(getTemporaryLinkArg, "api", "/files/get_temporary_link", Dropbox.Api.Files.GetTemporaryLinkArg.Encoder, Dropbox.Api.Files.GetTemporaryLinkResult.Decoder, Dropbox.Api.Files.GetTemporaryLinkError.Decoder);
        }

        /// <summary>
        /// <para>Begins an asynchronous send to the get temporary link route.</para>
        /// </summary>
        /// <param name="getTemporaryLinkArg">The request parameters.</param>
        /// <param name="callback">The method to be called when the asynchronous send is
        /// completed.</param>
        /// <param name="state">A user provided object that distinguished this send from other
        /// send requests.</param>
        /// <returns>An object that represents the asynchronous send request.</returns>
        public sys.IAsyncResult BeginGetTemporaryLink(GetTemporaryLinkArg getTemporaryLinkArg, sys.AsyncCallback callback, object state = null)
        {
            var task = this.GetTemporaryLinkAsync(getTemporaryLinkArg);

            return enc.Util.ToApm(task, callback, state);
        }

        /// <summary>
        /// <para>Get a temporary link to stream content of a file. This link will expire in
        /// four hours and afterwards you will get 410 Gone. Content-Type of the link is
        /// determined automatically by the file's mime type.</para>
        /// </summary>
        /// <param name="path">The path to the file you want a temporary link to.</param>
        /// <returns>The task that represents the asynchronous send operation. The TResult
        /// parameter contains the response from the server.</returns>
        /// <exception cref="Dropbox.Api.ApiException{TError}">Thrown if there is an error
        /// processing the request; This will contain a <see
        /// cref="GetTemporaryLinkError"/>.</exception>
        public t.Task<GetTemporaryLinkResult> GetTemporaryLinkAsync(string path)
        {
            var getTemporaryLinkArg = new GetTemporaryLinkArg(path);

            return this.GetTemporaryLinkAsync(getTemporaryLinkArg);
        }

        /// <summary>
        /// <para>Begins an asynchronous send to the get temporary link route.</para>
        /// </summary>
        /// <param name="path">The path to the file you want a temporary link to.</param>
        /// <param name="callback">The method to be called when the asynchronous send is
        /// completed.</param>
        /// <param name="callbackState">A user provided object that distinguished this send
        /// from other send requests.</param>
        /// <returns>An object that represents the asynchronous send request.</returns>
        public sys.IAsyncResult BeginGetTemporaryLink(string path,
                                                      sys.AsyncCallback callback,
                                                      object callbackState = null)
        {
            var getTemporaryLinkArg = new GetTemporaryLinkArg(path);

            return this.BeginGetTemporaryLink(getTemporaryLinkArg, callback, callbackState);
        }

        /// <summary>
        /// <para>Waits for the pending asynchronous send to the get temporary link route to
        /// complete</para>
        /// </summary>
        /// <param name="asyncResult">The reference to the pending asynchronous send
        /// request</param>
        /// <returns>The response to the send request</returns>
        /// <exception cref="Dropbox.Api.ApiException{TError}">Thrown if there is an error
        /// processing the request; This will contain a <see
        /// cref="GetTemporaryLinkError"/>.</exception>
        public GetTemporaryLinkResult EndGetTemporaryLink(sys.IAsyncResult asyncResult)
        {
            var task = asyncResult as t.Task<GetTemporaryLinkResult>;
            if (task == null)
            {
                throw new sys.InvalidOperationException();
            }

            return task.Result;
        }

        /// <summary>
        /// <para>Get a thumbnail for an image.</para>
        /// <para>This method currently supports files with the following file extensions: jpg,
        /// jpeg, png, tiff, tif, gif and bmp. Photos that are larger than 20MB in size won't
        /// be converted to a thumbnail.</para>
        /// </summary>
        /// <param name="thumbnailArg">The request parameters</param>
        /// <returns>The task that represents the asynchronous send operation. The TResult
        /// parameter contains the response from the server.</returns>
        /// <exception cref="Dropbox.Api.ApiException{TError}">Thrown if there is an error
        /// processing the request; This will contain a <see
        /// cref="ThumbnailError"/>.</exception>
        public t.Task<enc.IDownloadResponse<FileMetadata>> GetThumbnailAsync(ThumbnailArg thumbnailArg)
        {
            return this.Transport.SendDownloadRequestAsync<ThumbnailArg, FileMetadata, ThumbnailError>(thumbnailArg, "content", "/files/get_thumbnail", Dropbox.Api.Files.ThumbnailArg.Encoder, Dropbox.Api.Files.FileMetadata.Decoder, Dropbox.Api.Files.ThumbnailError.Decoder);
        }

        /// <summary>
        /// <para>Begins an asynchronous send to the get thumbnail route.</para>
        /// </summary>
        /// <param name="thumbnailArg">The request parameters.</param>
        /// <param name="callback">The method to be called when the asynchronous send is
        /// completed.</param>
        /// <param name="state">A user provided object that distinguished this send from other
        /// send requests.</param>
        /// <returns>An object that represents the asynchronous send request.</returns>
        public sys.IAsyncResult BeginGetThumbnail(ThumbnailArg thumbnailArg, sys.AsyncCallback callback, object state = null)
        {
            var task = this.GetThumbnailAsync(thumbnailArg);

            return enc.Util.ToApm(task, callback, state);
        }

        /// <summary>
        /// <para>Get a thumbnail for an image.</para>
        /// <para>This method currently supports files with the following file extensions: jpg,
        /// jpeg, png, tiff, tif, gif and bmp. Photos that are larger than 20MB in size won't
        /// be converted to a thumbnail.</para>
        /// </summary>
        /// <param name="path">The path to the image file you want to thumbnail.</param>
        /// <param name="format">The format for the thumbnail image, jpeg (default) or png. For
        /// images that are photos, jpeg should be preferred, while png is  better for
        /// screenshots and digital arts.</param>
        /// <param name="size">The size for the thumbnail image.</param>
        /// <returns>The task that represents the asynchronous send operation. The TResult
        /// parameter contains the response from the server.</returns>
        /// <exception cref="Dropbox.Api.ApiException{TError}">Thrown if there is an error
        /// processing the request; This will contain a <see
        /// cref="ThumbnailError"/>.</exception>
        public t.Task<enc.IDownloadResponse<FileMetadata>> GetThumbnailAsync(string path,
                                                                             ThumbnailFormat format = null,
                                                                             ThumbnailSize size = null)
        {
            var thumbnailArg = new ThumbnailArg(path,
                                                format,
                                                size);

            return this.GetThumbnailAsync(thumbnailArg);
        }

        /// <summary>
        /// <para>Begins an asynchronous send to the get thumbnail route.</para>
        /// </summary>
        /// <param name="path">The path to the image file you want to thumbnail.</param>
        /// <param name="format">The format for the thumbnail image, jpeg (default) or png. For
        /// images that are photos, jpeg should be preferred, while png is  better for
        /// screenshots and digital arts.</param>
        /// <param name="size">The size for the thumbnail image.</param>
        /// <param name="callback">The method to be called when the asynchronous send is
        /// completed.</param>
        /// <param name="callbackState">A user provided object that distinguished this send
        /// from other send requests.</param>
        /// <returns>An object that represents the asynchronous send request.</returns>
        public sys.IAsyncResult BeginGetThumbnail(string path,
                                                  ThumbnailFormat format = null,
                                                  ThumbnailSize size = null,
                                                  sys.AsyncCallback callback = null,
                                                  object callbackState = null)
        {
            var thumbnailArg = new ThumbnailArg(path,
                                                format,
                                                size);

            return this.BeginGetThumbnail(thumbnailArg, callback, callbackState);
        }

        /// <summary>
        /// <para>Waits for the pending asynchronous send to the get thumbnail route to
        /// complete</para>
        /// </summary>
        /// <param name="asyncResult">The reference to the pending asynchronous send
        /// request</param>
        /// <returns>The response to the send request</returns>
        /// <exception cref="Dropbox.Api.ApiException{TError}">Thrown if there is an error
        /// processing the request; This will contain a <see
        /// cref="ThumbnailError"/>.</exception>
        public enc.IDownloadResponse<FileMetadata> EndGetThumbnail(sys.IAsyncResult asyncResult)
        {
            var task = asyncResult as t.Task<enc.IDownloadResponse<FileMetadata>>;
            if (task == null)
            {
                throw new sys.InvalidOperationException();
            }

            return task.Result;
        }

        /// <summary>
        /// <para>Returns the contents of a folder.</para>
        /// </summary>
        /// <param name="listFolderArg">The request parameters</param>
        /// <returns>The task that represents the asynchronous send operation. The TResult
        /// parameter contains the response from the server.</returns>
        /// <exception cref="Dropbox.Api.ApiException{TError}">Thrown if there is an error
        /// processing the request; This will contain a <see
        /// cref="ListFolderError"/>.</exception>
        public t.Task<ListFolderResult> ListFolderAsync(ListFolderArg listFolderArg)
        {
            return this.Transport.SendRpcRequestAsync<ListFolderArg, ListFolderResult, ListFolderError>(listFolderArg, "api", "/files/list_folder", Dropbox.Api.Files.ListFolderArg.Encoder, Dropbox.Api.Files.ListFolderResult.Decoder, Dropbox.Api.Files.ListFolderError.Decoder);
        }

        /// <summary>
        /// <para>Begins an asynchronous send to the list folder route.</para>
        /// </summary>
        /// <param name="listFolderArg">The request parameters.</param>
        /// <param name="callback">The method to be called when the asynchronous send is
        /// completed.</param>
        /// <param name="state">A user provided object that distinguished this send from other
        /// send requests.</param>
        /// <returns>An object that represents the asynchronous send request.</returns>
        public sys.IAsyncResult BeginListFolder(ListFolderArg listFolderArg, sys.AsyncCallback callback, object state = null)
        {
            var task = this.ListFolderAsync(listFolderArg);

            return enc.Util.ToApm(task, callback, state);
        }

        /// <summary>
        /// <para>Returns the contents of a folder.</para>
        /// </summary>
        /// <param name="path">The path to the folder you want to see the contents of.</param>
        /// <param name="recursive">If true, the list folder operation will be applied
        /// recursively to all subfolders and the response will contain contents of all
        /// subfolders.</param>
        /// <param name="includeMediaInfo">If true, <see
        /// cref="Dropbox.Api.Files.FileMetadata.MediaInfo" /> is set for photo and
        /// video.</param>
        /// <param name="includeDeleted">If true, the results will include entries for files
        /// and folders that used to exist but were deleted.</param>
        /// <param name="includeHasExplicitSharedMembers">If true, the results will include a
        /// flag for each file indicating whether or not  that file has any explicit
        /// members.</param>
        /// <returns>The task that represents the asynchronous send operation. The TResult
        /// parameter contains the response from the server.</returns>
        /// <exception cref="Dropbox.Api.ApiException{TError}">Thrown if there is an error
        /// processing the request; This will contain a <see
        /// cref="ListFolderError"/>.</exception>
        public t.Task<ListFolderResult> ListFolderAsync(string path,
                                                        bool recursive = false,
                                                        bool includeMediaInfo = false,
                                                        bool includeDeleted = false,
                                                        bool includeHasExplicitSharedMembers = false)
        {
            var listFolderArg = new ListFolderArg(path,
                                                  recursive,
                                                  includeMediaInfo,
                                                  includeDeleted,
                                                  includeHasExplicitSharedMembers);

            return this.ListFolderAsync(listFolderArg);
        }

        /// <summary>
        /// <para>Begins an asynchronous send to the list folder route.</para>
        /// </summary>
        /// <param name="path">The path to the folder you want to see the contents of.</param>
        /// <param name="recursive">If true, the list folder operation will be applied
        /// recursively to all subfolders and the response will contain contents of all
        /// subfolders.</param>
        /// <param name="includeMediaInfo">If true, <see
        /// cref="Dropbox.Api.Files.FileMetadata.MediaInfo" /> is set for photo and
        /// video.</param>
        /// <param name="includeDeleted">If true, the results will include entries for files
        /// and folders that used to exist but were deleted.</param>
        /// <param name="includeHasExplicitSharedMembers">If true, the results will include a
        /// flag for each file indicating whether or not  that file has any explicit
        /// members.</param>
        /// <param name="callback">The method to be called when the asynchronous send is
        /// completed.</param>
        /// <param name="callbackState">A user provided object that distinguished this send
        /// from other send requests.</param>
        /// <returns>An object that represents the asynchronous send request.</returns>
        public sys.IAsyncResult BeginListFolder(string path,
                                                bool recursive = false,
                                                bool includeMediaInfo = false,
                                                bool includeDeleted = false,
                                                bool includeHasExplicitSharedMembers = false,
                                                sys.AsyncCallback callback = null,
                                                object callbackState = null)
        {
            var listFolderArg = new ListFolderArg(path,
                                                  recursive,
                                                  includeMediaInfo,
                                                  includeDeleted,
                                                  includeHasExplicitSharedMembers);

            return this.BeginListFolder(listFolderArg, callback, callbackState);
        }

        /// <summary>
        /// <para>Waits for the pending asynchronous send to the list folder route to
        /// complete</para>
        /// </summary>
        /// <param name="asyncResult">The reference to the pending asynchronous send
        /// request</param>
        /// <returns>The response to the send request</returns>
        /// <exception cref="Dropbox.Api.ApiException{TError}">Thrown if there is an error
        /// processing the request; This will contain a <see
        /// cref="ListFolderError"/>.</exception>
        public ListFolderResult EndListFolder(sys.IAsyncResult asyncResult)
        {
            var task = asyncResult as t.Task<ListFolderResult>;
            if (task == null)
            {
                throw new sys.InvalidOperationException();
            }

            return task.Result;
        }

        /// <summary>
        /// <para>Once a cursor has been retrieved from <see
        /// cref="Dropbox.Api.Files.Routes.FilesRoutes.ListFolderAsync" />, use this to
        /// paginate through all files and retrieve updates to the folder.</para>
        /// </summary>
        /// <param name="listFolderContinueArg">The request parameters</param>
        /// <returns>The task that represents the asynchronous send operation. The TResult
        /// parameter contains the response from the server.</returns>
        /// <exception cref="Dropbox.Api.ApiException{TError}">Thrown if there is an error
        /// processing the request; This will contain a <see
        /// cref="ListFolderContinueError"/>.</exception>
        public t.Task<ListFolderResult> ListFolderContinueAsync(ListFolderContinueArg listFolderContinueArg)
        {
            return this.Transport.SendRpcRequestAsync<ListFolderContinueArg, ListFolderResult, ListFolderContinueError>(listFolderContinueArg, "api", "/files/list_folder/continue", Dropbox.Api.Files.ListFolderContinueArg.Encoder, Dropbox.Api.Files.ListFolderResult.Decoder, Dropbox.Api.Files.ListFolderContinueError.Decoder);
        }

        /// <summary>
        /// <para>Begins an asynchronous send to the list folder continue route.</para>
        /// </summary>
        /// <param name="listFolderContinueArg">The request parameters.</param>
        /// <param name="callback">The method to be called when the asynchronous send is
        /// completed.</param>
        /// <param name="state">A user provided object that distinguished this send from other
        /// send requests.</param>
        /// <returns>An object that represents the asynchronous send request.</returns>
        public sys.IAsyncResult BeginListFolderContinue(ListFolderContinueArg listFolderContinueArg, sys.AsyncCallback callback, object state = null)
        {
            var task = this.ListFolderContinueAsync(listFolderContinueArg);

            return enc.Util.ToApm(task, callback, state);
        }

        /// <summary>
        /// <para>Once a cursor has been retrieved from <see
        /// cref="Dropbox.Api.Files.Routes.FilesRoutes.ListFolderAsync" />, use this to
        /// paginate through all files and retrieve updates to the folder.</para>
        /// </summary>
        /// <param name="cursor">The cursor returned by your last call to <see
        /// cref="Dropbox.Api.Files.Routes.FilesRoutes.ListFolderAsync" /> or <see
        /// cref="Dropbox.Api.Files.Routes.FilesRoutes.ListFolderContinueAsync" />.</param>
        /// <returns>The task that represents the asynchronous send operation. The TResult
        /// parameter contains the response from the server.</returns>
        /// <exception cref="Dropbox.Api.ApiException{TError}">Thrown if there is an error
        /// processing the request; This will contain a <see
        /// cref="ListFolderContinueError"/>.</exception>
        public t.Task<ListFolderResult> ListFolderContinueAsync(string cursor)
        {
            var listFolderContinueArg = new ListFolderContinueArg(cursor);

            return this.ListFolderContinueAsync(listFolderContinueArg);
        }

        /// <summary>
        /// <para>Begins an asynchronous send to the list folder continue route.</para>
        /// </summary>
        /// <param name="cursor">The cursor returned by your last call to <see
        /// cref="Dropbox.Api.Files.Routes.FilesRoutes.ListFolderAsync" /> or <see
        /// cref="Dropbox.Api.Files.Routes.FilesRoutes.ListFolderContinueAsync" />.</param>
        /// <param name="callback">The method to be called when the asynchronous send is
        /// completed.</param>
        /// <param name="callbackState">A user provided object that distinguished this send
        /// from other send requests.</param>
        /// <returns>An object that represents the asynchronous send request.</returns>
        public sys.IAsyncResult BeginListFolderContinue(string cursor,
                                                        sys.AsyncCallback callback,
                                                        object callbackState = null)
        {
            var listFolderContinueArg = new ListFolderContinueArg(cursor);

            return this.BeginListFolderContinue(listFolderContinueArg, callback, callbackState);
        }

        /// <summary>
        /// <para>Waits for the pending asynchronous send to the list folder continue route to
        /// complete</para>
        /// </summary>
        /// <param name="asyncResult">The reference to the pending asynchronous send
        /// request</param>
        /// <returns>The response to the send request</returns>
        /// <exception cref="Dropbox.Api.ApiException{TError}">Thrown if there is an error
        /// processing the request; This will contain a <see
        /// cref="ListFolderContinueError"/>.</exception>
        public ListFolderResult EndListFolderContinue(sys.IAsyncResult asyncResult)
        {
            var task = asyncResult as t.Task<ListFolderResult>;
            if (task == null)
            {
                throw new sys.InvalidOperationException();
            }

            return task.Result;
        }

        /// <summary>
        /// <para>A way to quickly get a cursor for the folder's state. Unlike <see
        /// cref="Dropbox.Api.Files.Routes.FilesRoutes.ListFolderAsync" />, <see
        /// cref="Dropbox.Api.Files.Routes.FilesRoutes.ListFolderGetLatestCursorAsync" />
        /// doesn't return any entries. This endpoint is for app which only needs to know about
        /// new files and modifications and doesn't need to know about files that already exist
        /// in Dropbox.</para>
        /// </summary>
        /// <param name="listFolderArg">The request parameters</param>
        /// <returns>The task that represents the asynchronous send operation. The TResult
        /// parameter contains the response from the server.</returns>
        /// <exception cref="Dropbox.Api.ApiException{TError}">Thrown if there is an error
        /// processing the request; This will contain a <see
        /// cref="ListFolderError"/>.</exception>
        public t.Task<ListFolderGetLatestCursorResult> ListFolderGetLatestCursorAsync(ListFolderArg listFolderArg)
        {
            return this.Transport.SendRpcRequestAsync<ListFolderArg, ListFolderGetLatestCursorResult, ListFolderError>(listFolderArg, "api", "/files/list_folder/get_latest_cursor", Dropbox.Api.Files.ListFolderArg.Encoder, Dropbox.Api.Files.ListFolderGetLatestCursorResult.Decoder, Dropbox.Api.Files.ListFolderError.Decoder);
        }

        /// <summary>
        /// <para>Begins an asynchronous send to the list folder get latest cursor
        /// route.</para>
        /// </summary>
        /// <param name="listFolderArg">The request parameters.</param>
        /// <param name="callback">The method to be called when the asynchronous send is
        /// completed.</param>
        /// <param name="state">A user provided object that distinguished this send from other
        /// send requests.</param>
        /// <returns>An object that represents the asynchronous send request.</returns>
        public sys.IAsyncResult BeginListFolderGetLatestCursor(ListFolderArg listFolderArg, sys.AsyncCallback callback, object state = null)
        {
            var task = this.ListFolderGetLatestCursorAsync(listFolderArg);

            return enc.Util.ToApm(task, callback, state);
        }

        /// <summary>
        /// <para>A way to quickly get a cursor for the folder's state. Unlike <see
        /// cref="Dropbox.Api.Files.Routes.FilesRoutes.ListFolderAsync" />, <see
        /// cref="Dropbox.Api.Files.Routes.FilesRoutes.ListFolderGetLatestCursorAsync" />
        /// doesn't return any entries. This endpoint is for app which only needs to know about
        /// new files and modifications and doesn't need to know about files that already exist
        /// in Dropbox.</para>
        /// </summary>
        /// <param name="path">The path to the folder you want to see the contents of.</param>
        /// <param name="recursive">If true, the list folder operation will be applied
        /// recursively to all subfolders and the response will contain contents of all
        /// subfolders.</param>
        /// <param name="includeMediaInfo">If true, <see
        /// cref="Dropbox.Api.Files.FileMetadata.MediaInfo" /> is set for photo and
        /// video.</param>
        /// <param name="includeDeleted">If true, the results will include entries for files
        /// and folders that used to exist but were deleted.</param>
        /// <param name="includeHasExplicitSharedMembers">If true, the results will include a
        /// flag for each file indicating whether or not  that file has any explicit
        /// members.</param>
        /// <returns>The task that represents the asynchronous send operation. The TResult
        /// parameter contains the response from the server.</returns>
        /// <exception cref="Dropbox.Api.ApiException{TError}">Thrown if there is an error
        /// processing the request; This will contain a <see
        /// cref="ListFolderError"/>.</exception>
        public t.Task<ListFolderGetLatestCursorResult> ListFolderGetLatestCursorAsync(string path,
                                                                                      bool recursive = false,
                                                                                      bool includeMediaInfo = false,
                                                                                      bool includeDeleted = false,
                                                                                      bool includeHasExplicitSharedMembers = false)
        {
            var listFolderArg = new ListFolderArg(path,
                                                  recursive,
                                                  includeMediaInfo,
                                                  includeDeleted,
                                                  includeHasExplicitSharedMembers);

            return this.ListFolderGetLatestCursorAsync(listFolderArg);
        }

        /// <summary>
        /// <para>Begins an asynchronous send to the list folder get latest cursor
        /// route.</para>
        /// </summary>
        /// <param name="path">The path to the folder you want to see the contents of.</param>
        /// <param name="recursive">If true, the list folder operation will be applied
        /// recursively to all subfolders and the response will contain contents of all
        /// subfolders.</param>
        /// <param name="includeMediaInfo">If true, <see
        /// cref="Dropbox.Api.Files.FileMetadata.MediaInfo" /> is set for photo and
        /// video.</param>
        /// <param name="includeDeleted">If true, the results will include entries for files
        /// and folders that used to exist but were deleted.</param>
        /// <param name="includeHasExplicitSharedMembers">If true, the results will include a
        /// flag for each file indicating whether or not  that file has any explicit
        /// members.</param>
        /// <param name="callback">The method to be called when the asynchronous send is
        /// completed.</param>
        /// <param name="callbackState">A user provided object that distinguished this send
        /// from other send requests.</param>
        /// <returns>An object that represents the asynchronous send request.</returns>
        public sys.IAsyncResult BeginListFolderGetLatestCursor(string path,
                                                               bool recursive = false,
                                                               bool includeMediaInfo = false,
                                                               bool includeDeleted = false,
                                                               bool includeHasExplicitSharedMembers = false,
                                                               sys.AsyncCallback callback = null,
                                                               object callbackState = null)
        {
            var listFolderArg = new ListFolderArg(path,
                                                  recursive,
                                                  includeMediaInfo,
                                                  includeDeleted,
                                                  includeHasExplicitSharedMembers);

            return this.BeginListFolderGetLatestCursor(listFolderArg, callback, callbackState);
        }

        /// <summary>
        /// <para>Waits for the pending asynchronous send to the list folder get latest cursor
        /// route to complete</para>
        /// </summary>
        /// <param name="asyncResult">The reference to the pending asynchronous send
        /// request</param>
        /// <returns>The response to the send request</returns>
        /// <exception cref="Dropbox.Api.ApiException{TError}">Thrown if there is an error
        /// processing the request; This will contain a <see
        /// cref="ListFolderError"/>.</exception>
        public ListFolderGetLatestCursorResult EndListFolderGetLatestCursor(sys.IAsyncResult asyncResult)
        {
            var task = asyncResult as t.Task<ListFolderGetLatestCursorResult>;
            if (task == null)
            {
                throw new sys.InvalidOperationException();
            }

            return task.Result;
        }

        /// <summary>
        /// <para>A longpoll endpoint to wait for changes on an account. In conjunction with
        /// <see cref="Dropbox.Api.Files.Routes.FilesRoutes.ListFolderContinueAsync" />, this
        /// call gives you a low-latency way to monitor an account for file changes. The
        /// connection will block until there are changes available or a timeout occurs. This
        /// endpoint is useful mostly for client-side apps. If you're looking for server-side
        /// notifications, check out our <a
        /// href="https://www.dropbox.com/developers/reference/webhooks">webhooks
        /// documentation</a>.</para>
        /// </summary>
        /// <param name="listFolderLongpollArg">The request parameters</param>
        /// <returns>The task that represents the asynchronous send operation. The TResult
        /// parameter contains the response from the server.</returns>
        /// <exception cref="Dropbox.Api.ApiException{TError}">Thrown if there is an error
        /// processing the request; This will contain a <see
        /// cref="ListFolderLongpollError"/>.</exception>
        public t.Task<ListFolderLongpollResult> ListFolderLongpollAsync(ListFolderLongpollArg listFolderLongpollArg)
        {
            return this.Transport.SendRpcRequestAsync<ListFolderLongpollArg, ListFolderLongpollResult, ListFolderLongpollError>(listFolderLongpollArg, "notify", "/files/list_folder/longpoll", Dropbox.Api.Files.ListFolderLongpollArg.Encoder, Dropbox.Api.Files.ListFolderLongpollResult.Decoder, Dropbox.Api.Files.ListFolderLongpollError.Decoder);
        }

        /// <summary>
        /// <para>Begins an asynchronous send to the list folder longpoll route.</para>
        /// </summary>
        /// <param name="listFolderLongpollArg">The request parameters.</param>
        /// <param name="callback">The method to be called when the asynchronous send is
        /// completed.</param>
        /// <param name="state">A user provided object that distinguished this send from other
        /// send requests.</param>
        /// <returns>An object that represents the asynchronous send request.</returns>
        public sys.IAsyncResult BeginListFolderLongpoll(ListFolderLongpollArg listFolderLongpollArg, sys.AsyncCallback callback, object state = null)
        {
            var task = this.ListFolderLongpollAsync(listFolderLongpollArg);

            return enc.Util.ToApm(task, callback, state);
        }

        /// <summary>
        /// <para>A longpoll endpoint to wait for changes on an account. In conjunction with
        /// <see cref="Dropbox.Api.Files.Routes.FilesRoutes.ListFolderContinueAsync" />, this
        /// call gives you a low-latency way to monitor an account for file changes. The
        /// connection will block until there are changes available or a timeout occurs. This
        /// endpoint is useful mostly for client-side apps. If you're looking for server-side
        /// notifications, check out our <a
        /// href="https://www.dropbox.com/developers/reference/webhooks">webhooks
        /// documentation</a>.</para>
        /// </summary>
        /// <param name="cursor">A cursor as returned by <see
        /// cref="Dropbox.Api.Files.Routes.FilesRoutes.ListFolderAsync" /> or <see
        /// cref="Dropbox.Api.Files.Routes.FilesRoutes.ListFolderContinueAsync" />. Cursors
        /// retrieved by setting <see cref="Dropbox.Api.Files.ListFolderArg.IncludeMediaInfo"
        /// /> to <c>true</c> are not supported.</param>
        /// <param name="timeout">A timeout in seconds. The request will block for at most this
        /// length of time, plus up to 90 seconds of random jitter added to avoid the
        /// thundering herd problem. Care should be taken when using this parameter, as some
        /// network infrastructure does not support long timeouts.</param>
        /// <returns>The task that represents the asynchronous send operation. The TResult
        /// parameter contains the response from the server.</returns>
        /// <exception cref="Dropbox.Api.ApiException{TError}">Thrown if there is an error
        /// processing the request; This will contain a <see
        /// cref="ListFolderLongpollError"/>.</exception>
        public t.Task<ListFolderLongpollResult> ListFolderLongpollAsync(string cursor,
                                                                        ulong timeout = 30)
        {
            var listFolderLongpollArg = new ListFolderLongpollArg(cursor,
                                                                  timeout);

            return this.ListFolderLongpollAsync(listFolderLongpollArg);
        }

        /// <summary>
        /// <para>Begins an asynchronous send to the list folder longpoll route.</para>
        /// </summary>
        /// <param name="cursor">A cursor as returned by <see
        /// cref="Dropbox.Api.Files.Routes.FilesRoutes.ListFolderAsync" /> or <see
        /// cref="Dropbox.Api.Files.Routes.FilesRoutes.ListFolderContinueAsync" />. Cursors
        /// retrieved by setting <see cref="Dropbox.Api.Files.ListFolderArg.IncludeMediaInfo"
        /// /> to <c>true</c> are not supported.</param>
        /// <param name="timeout">A timeout in seconds. The request will block for at most this
        /// length of time, plus up to 90 seconds of random jitter added to avoid the
        /// thundering herd problem. Care should be taken when using this parameter, as some
        /// network infrastructure does not support long timeouts.</param>
        /// <param name="callback">The method to be called when the asynchronous send is
        /// completed.</param>
        /// <param name="callbackState">A user provided object that distinguished this send
        /// from other send requests.</param>
        /// <returns>An object that represents the asynchronous send request.</returns>
        public sys.IAsyncResult BeginListFolderLongpoll(string cursor,
                                                        ulong timeout = 30,
                                                        sys.AsyncCallback callback = null,
                                                        object callbackState = null)
        {
            var listFolderLongpollArg = new ListFolderLongpollArg(cursor,
                                                                  timeout);

            return this.BeginListFolderLongpoll(listFolderLongpollArg, callback, callbackState);
        }

        /// <summary>
        /// <para>Waits for the pending asynchronous send to the list folder longpoll route to
        /// complete</para>
        /// </summary>
        /// <param name="asyncResult">The reference to the pending asynchronous send
        /// request</param>
        /// <returns>The response to the send request</returns>
        /// <exception cref="Dropbox.Api.ApiException{TError}">Thrown if there is an error
        /// processing the request; This will contain a <see
        /// cref="ListFolderLongpollError"/>.</exception>
        public ListFolderLongpollResult EndListFolderLongpoll(sys.IAsyncResult asyncResult)
        {
            var task = asyncResult as t.Task<ListFolderLongpollResult>;
            if (task == null)
            {
                throw new sys.InvalidOperationException();
            }

            return task.Result;
        }

        /// <summary>
        /// <para>Return revisions of a file</para>
        /// </summary>
        /// <param name="listRevisionsArg">The request parameters</param>
        /// <returns>The task that represents the asynchronous send operation. The TResult
        /// parameter contains the response from the server.</returns>
        /// <exception cref="Dropbox.Api.ApiException{TError}">Thrown if there is an error
        /// processing the request; This will contain a <see
        /// cref="ListRevisionsError"/>.</exception>
        public t.Task<ListRevisionsResult> ListRevisionsAsync(ListRevisionsArg listRevisionsArg)
        {
            return this.Transport.SendRpcRequestAsync<ListRevisionsArg, ListRevisionsResult, ListRevisionsError>(listRevisionsArg, "api", "/files/list_revisions", Dropbox.Api.Files.ListRevisionsArg.Encoder, Dropbox.Api.Files.ListRevisionsResult.Decoder, Dropbox.Api.Files.ListRevisionsError.Decoder);
        }

        /// <summary>
        /// <para>Begins an asynchronous send to the list revisions route.</para>
        /// </summary>
        /// <param name="listRevisionsArg">The request parameters.</param>
        /// <param name="callback">The method to be called when the asynchronous send is
        /// completed.</param>
        /// <param name="state">A user provided object that distinguished this send from other
        /// send requests.</param>
        /// <returns>An object that represents the asynchronous send request.</returns>
        public sys.IAsyncResult BeginListRevisions(ListRevisionsArg listRevisionsArg, sys.AsyncCallback callback, object state = null)
        {
            var task = this.ListRevisionsAsync(listRevisionsArg);

            return enc.Util.ToApm(task, callback, state);
        }

        /// <summary>
        /// <para>Return revisions of a file</para>
        /// </summary>
        /// <param name="path">The path to the file you want to see the revisions of.</param>
        /// <param name="limit">The maximum number of revision entries returned.</param>
        /// <returns>The task that represents the asynchronous send operation. The TResult
        /// parameter contains the response from the server.</returns>
        /// <exception cref="Dropbox.Api.ApiException{TError}">Thrown if there is an error
        /// processing the request; This will contain a <see
        /// cref="ListRevisionsError"/>.</exception>
        public t.Task<ListRevisionsResult> ListRevisionsAsync(string path,
                                                              ulong limit = 10)
        {
            var listRevisionsArg = new ListRevisionsArg(path,
                                                        limit);

            return this.ListRevisionsAsync(listRevisionsArg);
        }

        /// <summary>
        /// <para>Begins an asynchronous send to the list revisions route.</para>
        /// </summary>
        /// <param name="path">The path to the file you want to see the revisions of.</param>
        /// <param name="limit">The maximum number of revision entries returned.</param>
        /// <param name="callback">The method to be called when the asynchronous send is
        /// completed.</param>
        /// <param name="callbackState">A user provided object that distinguished this send
        /// from other send requests.</param>
        /// <returns>An object that represents the asynchronous send request.</returns>
        public sys.IAsyncResult BeginListRevisions(string path,
                                                   ulong limit = 10,
                                                   sys.AsyncCallback callback = null,
                                                   object callbackState = null)
        {
            var listRevisionsArg = new ListRevisionsArg(path,
                                                        limit);

            return this.BeginListRevisions(listRevisionsArg, callback, callbackState);
        }

        /// <summary>
        /// <para>Waits for the pending asynchronous send to the list revisions route to
        /// complete</para>
        /// </summary>
        /// <param name="asyncResult">The reference to the pending asynchronous send
        /// request</param>
        /// <returns>The response to the send request</returns>
        /// <exception cref="Dropbox.Api.ApiException{TError}">Thrown if there is an error
        /// processing the request; This will contain a <see
        /// cref="ListRevisionsError"/>.</exception>
        public ListRevisionsResult EndListRevisions(sys.IAsyncResult asyncResult)
        {
            var task = asyncResult as t.Task<ListRevisionsResult>;
            if (task == null)
            {
                throw new sys.InvalidOperationException();
            }

            return task.Result;
        }

        /// <summary>
        /// <para>Move a file or folder to a different location in the user's Dropbox.</para>
        /// <para>If the source path is a folder all its contents will be moved.</para>
        /// </summary>
        /// <param name="relocationArg">The request parameters</param>
        /// <returns>The task that represents the asynchronous send operation. The TResult
        /// parameter contains the response from the server.</returns>
        /// <exception cref="Dropbox.Api.ApiException{TError}">Thrown if there is an error
        /// processing the request; This will contain a <see
        /// cref="RelocationError"/>.</exception>
        public t.Task<Metadata> MoveAsync(RelocationArg relocationArg)
        {
            return this.Transport.SendRpcRequestAsync<RelocationArg, Metadata, RelocationError>(relocationArg, "api", "/files/move", Dropbox.Api.Files.RelocationArg.Encoder, Dropbox.Api.Files.Metadata.Decoder, Dropbox.Api.Files.RelocationError.Decoder);
        }

        /// <summary>
        /// <para>Begins an asynchronous send to the move route.</para>
        /// </summary>
        /// <param name="relocationArg">The request parameters.</param>
        /// <param name="callback">The method to be called when the asynchronous send is
        /// completed.</param>
        /// <param name="state">A user provided object that distinguished this send from other
        /// send requests.</param>
        /// <returns>An object that represents the asynchronous send request.</returns>
        public sys.IAsyncResult BeginMove(RelocationArg relocationArg, sys.AsyncCallback callback, object state = null)
        {
            var task = this.MoveAsync(relocationArg);

            return enc.Util.ToApm(task, callback, state);
        }

        /// <summary>
        /// <para>Move a file or folder to a different location in the user's Dropbox.</para>
        /// <para>If the source path is a folder all its contents will be moved.</para>
        /// </summary>
        /// <param name="fromPath">Path in the user's Dropbox to be copied or moved.</param>
        /// <param name="toPath">Path in the user's Dropbox that is the destination.</param>
        /// <returns>The task that represents the asynchronous send operation. The TResult
        /// parameter contains the response from the server.</returns>
        /// <exception cref="Dropbox.Api.ApiException{TError}">Thrown if there is an error
        /// processing the request; This will contain a <see
        /// cref="RelocationError"/>.</exception>
        public t.Task<Metadata> MoveAsync(string fromPath,
                                          string toPath)
        {
            var relocationArg = new RelocationArg(fromPath,
                                                  toPath);

            return this.MoveAsync(relocationArg);
        }

        /// <summary>
        /// <para>Begins an asynchronous send to the move route.</para>
        /// </summary>
        /// <param name="fromPath">Path in the user's Dropbox to be copied or moved.</param>
        /// <param name="toPath">Path in the user's Dropbox that is the destination.</param>
        /// <param name="callback">The method to be called when the asynchronous send is
        /// completed.</param>
        /// <param name="callbackState">A user provided object that distinguished this send
        /// from other send requests.</param>
        /// <returns>An object that represents the asynchronous send request.</returns>
        public sys.IAsyncResult BeginMove(string fromPath,
                                          string toPath,
                                          sys.AsyncCallback callback,
                                          object callbackState = null)
        {
            var relocationArg = new RelocationArg(fromPath,
                                                  toPath);

            return this.BeginMove(relocationArg, callback, callbackState);
        }

        /// <summary>
        /// <para>Waits for the pending asynchronous send to the move route to complete</para>
        /// </summary>
        /// <param name="asyncResult">The reference to the pending asynchronous send
        /// request</param>
        /// <returns>The response to the send request</returns>
        /// <exception cref="Dropbox.Api.ApiException{TError}">Thrown if there is an error
        /// processing the request; This will contain a <see
        /// cref="RelocationError"/>.</exception>
        public Metadata EndMove(sys.IAsyncResult asyncResult)
        {
            var task = asyncResult as t.Task<Metadata>;
            if (task == null)
            {
                throw new sys.InvalidOperationException();
            }

            return task.Result;
        }

        /// <summary>
        /// <para>Permanently delete the file or folder at a given path (see
        /// https://www.dropbox.com/en/help/40).</para>
        /// <para>Note: This endpoint is only available for Dropbox Business apps.</para>
        /// </summary>
        /// <param name="deleteArg">The request parameters</param>
        /// <returns>The task that represents the asynchronous send operation.</returns>
        /// <exception cref="Dropbox.Api.ApiException{TError}">Thrown if there is an error
        /// processing the request; This will contain a <see cref="DeleteError"/>.</exception>
        public t.Task PermanentlyDeleteAsync(DeleteArg deleteArg)
        {
            return this.Transport.SendRpcRequestAsync<DeleteArg, enc.Empty, DeleteError>(deleteArg, "api", "/files/permanently_delete", Dropbox.Api.Files.DeleteArg.Encoder, enc.EmptyDecoder.Instance, Dropbox.Api.Files.DeleteError.Decoder);
        }

        /// <summary>
        /// <para>Begins an asynchronous send to the permanently delete route.</para>
        /// </summary>
        /// <param name="deleteArg">The request parameters.</param>
        /// <param name="callback">The method to be called when the asynchronous send is
        /// completed.</param>
        /// <param name="state">A user provided object that distinguished this send from other
        /// send requests.</param>
        /// <returns>An object that represents the asynchronous send request.</returns>
        public sys.IAsyncResult BeginPermanentlyDelete(DeleteArg deleteArg, sys.AsyncCallback callback, object state = null)
        {
            var task = this.PermanentlyDeleteAsync(deleteArg);

            return enc.Util.ToApm(task, callback, state);
        }

        /// <summary>
        /// <para>Permanently delete the file or folder at a given path (see
        /// https://www.dropbox.com/en/help/40).</para>
        /// <para>Note: This endpoint is only available for Dropbox Business apps.</para>
        /// </summary>
        /// <param name="path">Path in the user's Dropbox to delete.</param>
        /// <returns>The task that represents the asynchronous send operation.</returns>
        /// <exception cref="Dropbox.Api.ApiException{TError}">Thrown if there is an error
        /// processing the request; This will contain a <see cref="DeleteError"/>.</exception>
        public t.Task PermanentlyDeleteAsync(string path)
        {
            var deleteArg = new DeleteArg(path);

            return this.PermanentlyDeleteAsync(deleteArg);
        }

        /// <summary>
        /// <para>Begins an asynchronous send to the permanently delete route.</para>
        /// </summary>
        /// <param name="path">Path in the user's Dropbox to delete.</param>
        /// <param name="callback">The method to be called when the asynchronous send is
        /// completed.</param>
        /// <param name="callbackState">A user provided object that distinguished this send
        /// from other send requests.</param>
        /// <returns>An object that represents the asynchronous send request.</returns>
        public sys.IAsyncResult BeginPermanentlyDelete(string path,
                                                       sys.AsyncCallback callback,
                                                       object callbackState = null)
        {
            var deleteArg = new DeleteArg(path);

            return this.BeginPermanentlyDelete(deleteArg, callback, callbackState);
        }

        /// <summary>
        /// <para>Waits for the pending asynchronous send to the permanently delete route to
        /// complete</para>
        /// </summary>
        /// <param name="asyncResult">The reference to the pending asynchronous send
        /// request</param>
        /// <exception cref="Dropbox.Api.ApiException{TError}">Thrown if there is an error
        /// processing the request; This will contain a <see cref="DeleteError"/>.</exception>
        public void EndPermanentlyDelete(sys.IAsyncResult asyncResult)
        {
            var task = asyncResult as t.Task;
            if (task == null)
            {
                throw new sys.InvalidOperationException();
            }
        }

        /// <summary>
        /// <para>Add custom properties to a file using a filled property template. See
        /// properties/template/add to create new property templates.</para>
        /// </summary>
        /// <param name="propertyGroupWithPath">The request parameters</param>
        /// <returns>The task that represents the asynchronous send operation.</returns>
        /// <exception cref="Dropbox.Api.ApiException{TError}">Thrown if there is an error
        /// processing the request; This will contain a <see
        /// cref="AddPropertiesError"/>.</exception>
        public t.Task PropertiesAddAsync(PropertyGroupWithPath propertyGroupWithPath)
        {
            return this.Transport.SendRpcRequestAsync<PropertyGroupWithPath, enc.Empty, AddPropertiesError>(propertyGroupWithPath, "api", "/files/properties/add", Dropbox.Api.Files.PropertyGroupWithPath.Encoder, enc.EmptyDecoder.Instance, Dropbox.Api.Files.AddPropertiesError.Decoder);
        }

        /// <summary>
        /// <para>Begins an asynchronous send to the properties add route.</para>
        /// </summary>
        /// <param name="propertyGroupWithPath">The request parameters.</param>
        /// <param name="callback">The method to be called when the asynchronous send is
        /// completed.</param>
        /// <param name="state">A user provided object that distinguished this send from other
        /// send requests.</param>
        /// <returns>An object that represents the asynchronous send request.</returns>
        public sys.IAsyncResult BeginPropertiesAdd(PropertyGroupWithPath propertyGroupWithPath, sys.AsyncCallback callback, object state = null)
        {
            var task = this.PropertiesAddAsync(propertyGroupWithPath);

            return enc.Util.ToApm(task, callback, state);
        }

        /// <summary>
        /// <para>Add custom properties to a file using a filled property template. See
        /// properties/template/add to create new property templates.</para>
        /// </summary>
        /// <param name="path">A unique identifier for the file.</param>
        /// <param name="propertyGroups">Filled custom property templates associated with a
        /// file.</param>
        /// <returns>The task that represents the asynchronous send operation.</returns>
        /// <exception cref="Dropbox.Api.ApiException{TError}">Thrown if there is an error
        /// processing the request; This will contain a <see
        /// cref="AddPropertiesError"/>.</exception>
        public t.Task PropertiesAddAsync(string path,
                                         col.IEnumerable<Dropbox.Api.Properties.PropertyGroup> propertyGroups)
        {
            var propertyGroupWithPath = new PropertyGroupWithPath(path,
                                                                  propertyGroups);

            return this.PropertiesAddAsync(propertyGroupWithPath);
        }

        /// <summary>
        /// <para>Begins an asynchronous send to the properties add route.</para>
        /// </summary>
        /// <param name="path">A unique identifier for the file.</param>
        /// <param name="propertyGroups">Filled custom property templates associated with a
        /// file.</param>
        /// <param name="callback">The method to be called when the asynchronous send is
        /// completed.</param>
        /// <param name="callbackState">A user provided object that distinguished this send
        /// from other send requests.</param>
        /// <returns>An object that represents the asynchronous send request.</returns>
        public sys.IAsyncResult BeginPropertiesAdd(string path,
                                                   col.IEnumerable<Dropbox.Api.Properties.PropertyGroup> propertyGroups,
                                                   sys.AsyncCallback callback,
                                                   object callbackState = null)
        {
            var propertyGroupWithPath = new PropertyGroupWithPath(path,
                                                                  propertyGroups);

            return this.BeginPropertiesAdd(propertyGroupWithPath, callback, callbackState);
        }

        /// <summary>
        /// <para>Waits for the pending asynchronous send to the properties add route to
        /// complete</para>
        /// </summary>
        /// <param name="asyncResult">The reference to the pending asynchronous send
        /// request</param>
        /// <exception cref="Dropbox.Api.ApiException{TError}">Thrown if there is an error
        /// processing the request; This will contain a <see
        /// cref="AddPropertiesError"/>.</exception>
        public void EndPropertiesAdd(sys.IAsyncResult asyncResult)
        {
            var task = asyncResult as t.Task;
            if (task == null)
            {
                throw new sys.InvalidOperationException();
            }
        }

        /// <summary>
        /// <para>Overwrite custom properties from a specified template associated with a
        /// file.</para>
        /// </summary>
        /// <param name="propertyGroupWithPath">The request parameters</param>
        /// <returns>The task that represents the asynchronous send operation.</returns>
        /// <exception cref="Dropbox.Api.ApiException{TError}">Thrown if there is an error
        /// processing the request; This will contain a <see
        /// cref="InvalidPropertyGroupError"/>.</exception>
        public t.Task PropertiesOverwriteAsync(PropertyGroupWithPath propertyGroupWithPath)
        {
            return this.Transport.SendRpcRequestAsync<PropertyGroupWithPath, enc.Empty, InvalidPropertyGroupError>(propertyGroupWithPath, "api", "/files/properties/overwrite", Dropbox.Api.Files.PropertyGroupWithPath.Encoder, enc.EmptyDecoder.Instance, Dropbox.Api.Files.InvalidPropertyGroupError.Decoder);
        }

        /// <summary>
        /// <para>Begins an asynchronous send to the properties overwrite route.</para>
        /// </summary>
        /// <param name="propertyGroupWithPath">The request parameters.</param>
        /// <param name="callback">The method to be called when the asynchronous send is
        /// completed.</param>
        /// <param name="state">A user provided object that distinguished this send from other
        /// send requests.</param>
        /// <returns>An object that represents the asynchronous send request.</returns>
        public sys.IAsyncResult BeginPropertiesOverwrite(PropertyGroupWithPath propertyGroupWithPath, sys.AsyncCallback callback, object state = null)
        {
            var task = this.PropertiesOverwriteAsync(propertyGroupWithPath);

            return enc.Util.ToApm(task, callback, state);
        }

        /// <summary>
        /// <para>Overwrite custom properties from a specified template associated with a
        /// file.</para>
        /// </summary>
        /// <param name="path">A unique identifier for the file.</param>
        /// <param name="propertyGroups">Filled custom property templates associated with a
        /// file.</param>
        /// <returns>The task that represents the asynchronous send operation.</returns>
        /// <exception cref="Dropbox.Api.ApiException{TError}">Thrown if there is an error
        /// processing the request; This will contain a <see
        /// cref="InvalidPropertyGroupError"/>.</exception>
        public t.Task PropertiesOverwriteAsync(string path,
                                               col.IEnumerable<Dropbox.Api.Properties.PropertyGroup> propertyGroups)
        {
            var propertyGroupWithPath = new PropertyGroupWithPath(path,
                                                                  propertyGroups);

            return this.PropertiesOverwriteAsync(propertyGroupWithPath);
        }

        /// <summary>
        /// <para>Begins an asynchronous send to the properties overwrite route.</para>
        /// </summary>
        /// <param name="path">A unique identifier for the file.</param>
        /// <param name="propertyGroups">Filled custom property templates associated with a
        /// file.</param>
        /// <param name="callback">The method to be called when the asynchronous send is
        /// completed.</param>
        /// <param name="callbackState">A user provided object that distinguished this send
        /// from other send requests.</param>
        /// <returns>An object that represents the asynchronous send request.</returns>
        public sys.IAsyncResult BeginPropertiesOverwrite(string path,
                                                         col.IEnumerable<Dropbox.Api.Properties.PropertyGroup> propertyGroups,
                                                         sys.AsyncCallback callback,
                                                         object callbackState = null)
        {
            var propertyGroupWithPath = new PropertyGroupWithPath(path,
                                                                  propertyGroups);

            return this.BeginPropertiesOverwrite(propertyGroupWithPath, callback, callbackState);
        }

        /// <summary>
        /// <para>Waits for the pending asynchronous send to the properties overwrite route to
        /// complete</para>
        /// </summary>
        /// <param name="asyncResult">The reference to the pending asynchronous send
        /// request</param>
        /// <exception cref="Dropbox.Api.ApiException{TError}">Thrown if there is an error
        /// processing the request; This will contain a <see
        /// cref="InvalidPropertyGroupError"/>.</exception>
        public void EndPropertiesOverwrite(sys.IAsyncResult asyncResult)
        {
            var task = asyncResult as t.Task;
            if (task == null)
            {
                throw new sys.InvalidOperationException();
            }
        }

        /// <summary>
        /// <para>Remove all custom properties from a specified template associated with a
        /// file. To remove specific property key value pairs, see <see
        /// cref="Dropbox.Api.Files.Routes.FilesRoutes.PropertiesUpdateAsync" />. To update a
        /// property template, see properties/template/update. Property templates can't be
        /// removed once created.</para>
        /// </summary>
        /// <param name="removePropertiesArg">The request parameters</param>
        /// <returns>The task that represents the asynchronous send operation.</returns>
        /// <exception cref="Dropbox.Api.ApiException{TError}">Thrown if there is an error
        /// processing the request; This will contain a <see
        /// cref="RemovePropertiesError"/>.</exception>
        public t.Task PropertiesRemoveAsync(RemovePropertiesArg removePropertiesArg)
        {
            return this.Transport.SendRpcRequestAsync<RemovePropertiesArg, enc.Empty, RemovePropertiesError>(removePropertiesArg, "api", "/files/properties/remove", Dropbox.Api.Files.RemovePropertiesArg.Encoder, enc.EmptyDecoder.Instance, Dropbox.Api.Files.RemovePropertiesError.Decoder);
        }

        /// <summary>
        /// <para>Begins an asynchronous send to the properties remove route.</para>
        /// </summary>
        /// <param name="removePropertiesArg">The request parameters.</param>
        /// <param name="callback">The method to be called when the asynchronous send is
        /// completed.</param>
        /// <param name="state">A user provided object that distinguished this send from other
        /// send requests.</param>
        /// <returns>An object that represents the asynchronous send request.</returns>
        public sys.IAsyncResult BeginPropertiesRemove(RemovePropertiesArg removePropertiesArg, sys.AsyncCallback callback, object state = null)
        {
            var task = this.PropertiesRemoveAsync(removePropertiesArg);

            return enc.Util.ToApm(task, callback, state);
        }

        /// <summary>
        /// <para>Remove all custom properties from a specified template associated with a
        /// file. To remove specific property key value pairs, see <see
        /// cref="Dropbox.Api.Files.Routes.FilesRoutes.PropertiesUpdateAsync" />. To update a
        /// property template, see properties/template/update. Property templates can't be
        /// removed once created.</para>
        /// </summary>
        /// <param name="path">A unique identifier for the file.</param>
        /// <param name="propertyTemplateIds">A list of identifiers for a property template
        /// created by route properties/template/add.</param>
        /// <returns>The task that represents the asynchronous send operation.</returns>
        /// <exception cref="Dropbox.Api.ApiException{TError}">Thrown if there is an error
        /// processing the request; This will contain a <see
        /// cref="RemovePropertiesError"/>.</exception>
        public t.Task PropertiesRemoveAsync(string path,
                                            col.IEnumerable<string> propertyTemplateIds)
        {
            var removePropertiesArg = new RemovePropertiesArg(path,
                                                              propertyTemplateIds);

            return this.PropertiesRemoveAsync(removePropertiesArg);
        }

        /// <summary>
        /// <para>Begins an asynchronous send to the properties remove route.</para>
        /// </summary>
        /// <param name="path">A unique identifier for the file.</param>
        /// <param name="propertyTemplateIds">A list of identifiers for a property template
        /// created by route properties/template/add.</param>
        /// <param name="callback">The method to be called when the asynchronous send is
        /// completed.</param>
        /// <param name="callbackState">A user provided object that distinguished this send
        /// from other send requests.</param>
        /// <returns>An object that represents the asynchronous send request.</returns>
        public sys.IAsyncResult BeginPropertiesRemove(string path,
                                                      col.IEnumerable<string> propertyTemplateIds,
                                                      sys.AsyncCallback callback,
                                                      object callbackState = null)
        {
            var removePropertiesArg = new RemovePropertiesArg(path,
                                                              propertyTemplateIds);

            return this.BeginPropertiesRemove(removePropertiesArg, callback, callbackState);
        }

        /// <summary>
        /// <para>Waits for the pending asynchronous send to the properties remove route to
        /// complete</para>
        /// </summary>
        /// <param name="asyncResult">The reference to the pending asynchronous send
        /// request</param>
        /// <exception cref="Dropbox.Api.ApiException{TError}">Thrown if there is an error
        /// processing the request; This will contain a <see
        /// cref="RemovePropertiesError"/>.</exception>
        public void EndPropertiesRemove(sys.IAsyncResult asyncResult)
        {
            var task = asyncResult as t.Task;
            if (task == null)
            {
                throw new sys.InvalidOperationException();
            }
        }

        /// <summary>
        /// <para>Get the schema for a specified template.</para>
        /// </summary>
        /// <param name="getPropertyTemplateArg">The request parameters</param>
        /// <returns>The task that represents the asynchronous send operation. The TResult
        /// parameter contains the response from the server.</returns>
        /// <exception cref="Dropbox.Api.ApiException{TError}">Thrown if there is an error
        /// processing the request; This will contain a <see
        /// cref="Dropbox.Api.Properties.PropertyTemplateError"/>.</exception>
        public t.Task<Dropbox.Api.Properties.GetPropertyTemplateResult> PropertiesTemplateGetAsync(Dropbox.Api.Properties.GetPropertyTemplateArg getPropertyTemplateArg)
        {
            return this.Transport.SendRpcRequestAsync<Dropbox.Api.Properties.GetPropertyTemplateArg, Dropbox.Api.Properties.GetPropertyTemplateResult, Dropbox.Api.Properties.PropertyTemplateError>(getPropertyTemplateArg, "api", "/files/properties/template/get", Dropbox.Api.Properties.GetPropertyTemplateArg.Encoder, Dropbox.Api.Properties.GetPropertyTemplateResult.Decoder, Dropbox.Api.Properties.PropertyTemplateError.Decoder);
        }

        /// <summary>
        /// <para>Begins an asynchronous send to the properties template get route.</para>
        /// </summary>
        /// <param name="getPropertyTemplateArg">The request parameters.</param>
        /// <param name="callback">The method to be called when the asynchronous send is
        /// completed.</param>
        /// <param name="state">A user provided object that distinguished this send from other
        /// send requests.</param>
        /// <returns>An object that represents the asynchronous send request.</returns>
        public sys.IAsyncResult BeginPropertiesTemplateGet(Dropbox.Api.Properties.GetPropertyTemplateArg getPropertyTemplateArg, sys.AsyncCallback callback, object state = null)
        {
            var task = this.PropertiesTemplateGetAsync(getPropertyTemplateArg);

            return enc.Util.ToApm(task, callback, state);
        }

        /// <summary>
        /// <para>Get the schema for a specified template.</para>
        /// </summary>
        /// <param name="templateId">An identifier for property template added by route
        /// properties/template/add.</param>
        /// <returns>The task that represents the asynchronous send operation. The TResult
        /// parameter contains the response from the server.</returns>
        /// <exception cref="Dropbox.Api.ApiException{TError}">Thrown if there is an error
        /// processing the request; This will contain a <see
        /// cref="Dropbox.Api.Properties.PropertyTemplateError"/>.</exception>
        public t.Task<Dropbox.Api.Properties.GetPropertyTemplateResult> PropertiesTemplateGetAsync(string templateId)
        {
            var getPropertyTemplateArg = new Dropbox.Api.Properties.GetPropertyTemplateArg(templateId);

            return this.PropertiesTemplateGetAsync(getPropertyTemplateArg);
        }

        /// <summary>
        /// <para>Begins an asynchronous send to the properties template get route.</para>
        /// </summary>
        /// <param name="templateId">An identifier for property template added by route
        /// properties/template/add.</param>
        /// <param name="callback">The method to be called when the asynchronous send is
        /// completed.</param>
        /// <param name="callbackState">A user provided object that distinguished this send
        /// from other send requests.</param>
        /// <returns>An object that represents the asynchronous send request.</returns>
        public sys.IAsyncResult BeginPropertiesTemplateGet(string templateId,
                                                           sys.AsyncCallback callback,
                                                           object callbackState = null)
        {
            var getPropertyTemplateArg = new Dropbox.Api.Properties.GetPropertyTemplateArg(templateId);

            return this.BeginPropertiesTemplateGet(getPropertyTemplateArg, callback, callbackState);
        }

        /// <summary>
        /// <para>Waits for the pending asynchronous send to the properties template get route
        /// to complete</para>
        /// </summary>
        /// <param name="asyncResult">The reference to the pending asynchronous send
        /// request</param>
        /// <returns>The response to the send request</returns>
        /// <exception cref="Dropbox.Api.ApiException{TError}">Thrown if there is an error
        /// processing the request; This will contain a <see
        /// cref="Dropbox.Api.Properties.PropertyTemplateError"/>.</exception>
        public Dropbox.Api.Properties.GetPropertyTemplateResult EndPropertiesTemplateGet(sys.IAsyncResult asyncResult)
        {
            var task = asyncResult as t.Task<Dropbox.Api.Properties.GetPropertyTemplateResult>;
            if (task == null)
            {
                throw new sys.InvalidOperationException();
            }

            return task.Result;
        }

        /// <summary>
        /// <para>Get the property template identifiers for a user. To get the schema of each
        /// template use <see
        /// cref="Dropbox.Api.Files.Routes.FilesRoutes.PropertiesTemplateGetAsync" />.</para>
        /// </summary>
        /// <returns>The task that represents the asynchronous send operation. The TResult
        /// parameter contains the response from the server.</returns>
        /// <exception cref="Dropbox.Api.ApiException{TError}">Thrown if there is an error
        /// processing the request; This will contain a <see
        /// cref="Dropbox.Api.Properties.PropertyTemplateError"/>.</exception>
        public t.Task<Dropbox.Api.Properties.ListPropertyTemplateIds> PropertiesTemplateListAsync()
        {
            return this.Transport.SendRpcRequestAsync<enc.Empty, Dropbox.Api.Properties.ListPropertyTemplateIds, Dropbox.Api.Properties.PropertyTemplateError>(enc.Empty.Instance, "api", "/files/properties/template/list", enc.EmptyEncoder.Instance, Dropbox.Api.Properties.ListPropertyTemplateIds.Decoder, Dropbox.Api.Properties.PropertyTemplateError.Decoder);
        }

        /// <summary>
        /// <para>Begins an asynchronous send to the properties template list route.</para>
        /// </summary>
        /// <param name="callback">The method to be called when the asynchronous send is
        /// completed.</param>
        /// <param name="state">A user provided object that distinguished this send from other
        /// send requests.</param>
        /// <returns>An object that represents the asynchronous send request.</returns>
        public sys.IAsyncResult BeginPropertiesTemplateList(sys.AsyncCallback callback, object state = null)
        {
            var task = this.PropertiesTemplateListAsync();

            return enc.Util.ToApm(task, callback, state);
        }

        /// <summary>
        /// <para>Waits for the pending asynchronous send to the properties template list route
        /// to complete</para>
        /// </summary>
        /// <param name="asyncResult">The reference to the pending asynchronous send
        /// request</param>
        /// <returns>The response to the send request</returns>
        /// <exception cref="Dropbox.Api.ApiException{TError}">Thrown if there is an error
        /// processing the request; This will contain a <see
        /// cref="Dropbox.Api.Properties.PropertyTemplateError"/>.</exception>
        public Dropbox.Api.Properties.ListPropertyTemplateIds EndPropertiesTemplateList(sys.IAsyncResult asyncResult)
        {
            var task = asyncResult as t.Task<Dropbox.Api.Properties.ListPropertyTemplateIds>;
            if (task == null)
            {
                throw new sys.InvalidOperationException();
            }

            return task.Result;
        }

        /// <summary>
        /// <para>Add, update or remove custom properties from a specified template associated
        /// with a file. Fields that already exist and not described in the request will not be
        /// modified.</para>
        /// </summary>
        /// <param name="updatePropertyGroupArg">The request parameters</param>
        /// <returns>The task that represents the asynchronous send operation.</returns>
        /// <exception cref="Dropbox.Api.ApiException{TError}">Thrown if there is an error
        /// processing the request; This will contain a <see
        /// cref="UpdatePropertiesError"/>.</exception>
        public t.Task PropertiesUpdateAsync(UpdatePropertyGroupArg updatePropertyGroupArg)
        {
            return this.Transport.SendRpcRequestAsync<UpdatePropertyGroupArg, enc.Empty, UpdatePropertiesError>(updatePropertyGroupArg, "api", "/files/properties/update", Dropbox.Api.Files.UpdatePropertyGroupArg.Encoder, enc.EmptyDecoder.Instance, Dropbox.Api.Files.UpdatePropertiesError.Decoder);
        }

        /// <summary>
        /// <para>Begins an asynchronous send to the properties update route.</para>
        /// </summary>
        /// <param name="updatePropertyGroupArg">The request parameters.</param>
        /// <param name="callback">The method to be called when the asynchronous send is
        /// completed.</param>
        /// <param name="state">A user provided object that distinguished this send from other
        /// send requests.</param>
        /// <returns>An object that represents the asynchronous send request.</returns>
        public sys.IAsyncResult BeginPropertiesUpdate(UpdatePropertyGroupArg updatePropertyGroupArg, sys.AsyncCallback callback, object state = null)
        {
            var task = this.PropertiesUpdateAsync(updatePropertyGroupArg);

            return enc.Util.ToApm(task, callback, state);
        }

        /// <summary>
        /// <para>Add, update or remove custom properties from a specified template associated
        /// with a file. Fields that already exist and not described in the request will not be
        /// modified.</para>
        /// </summary>
        /// <param name="path">A unique identifier for the file.</param>
        /// <param name="updatePropertyGroups">Filled custom property templates associated with
        /// a file.</param>
        /// <returns>The task that represents the asynchronous send operation.</returns>
        /// <exception cref="Dropbox.Api.ApiException{TError}">Thrown if there is an error
        /// processing the request; This will contain a <see
        /// cref="UpdatePropertiesError"/>.</exception>
        public t.Task PropertiesUpdateAsync(string path,
                                            col.IEnumerable<PropertyGroupUpdate> updatePropertyGroups)
        {
            var updatePropertyGroupArg = new UpdatePropertyGroupArg(path,
                                                                    updatePropertyGroups);

            return this.PropertiesUpdateAsync(updatePropertyGroupArg);
        }

        /// <summary>
        /// <para>Begins an asynchronous send to the properties update route.</para>
        /// </summary>
        /// <param name="path">A unique identifier for the file.</param>
        /// <param name="updatePropertyGroups">Filled custom property templates associated with
        /// a file.</param>
        /// <param name="callback">The method to be called when the asynchronous send is
        /// completed.</param>
        /// <param name="callbackState">A user provided object that distinguished this send
        /// from other send requests.</param>
        /// <returns>An object that represents the asynchronous send request.</returns>
        public sys.IAsyncResult BeginPropertiesUpdate(string path,
                                                      col.IEnumerable<PropertyGroupUpdate> updatePropertyGroups,
                                                      sys.AsyncCallback callback,
                                                      object callbackState = null)
        {
            var updatePropertyGroupArg = new UpdatePropertyGroupArg(path,
                                                                    updatePropertyGroups);

            return this.BeginPropertiesUpdate(updatePropertyGroupArg, callback, callbackState);
        }

        /// <summary>
        /// <para>Waits for the pending asynchronous send to the properties update route to
        /// complete</para>
        /// </summary>
        /// <param name="asyncResult">The reference to the pending asynchronous send
        /// request</param>
        /// <exception cref="Dropbox.Api.ApiException{TError}">Thrown if there is an error
        /// processing the request; This will contain a <see
        /// cref="UpdatePropertiesError"/>.</exception>
        public void EndPropertiesUpdate(sys.IAsyncResult asyncResult)
        {
            var task = asyncResult as t.Task;
            if (task == null)
            {
                throw new sys.InvalidOperationException();
            }
        }

        /// <summary>
        /// <para>Restore a file to a specific revision</para>
        /// </summary>
        /// <param name="restoreArg">The request parameters</param>
        /// <returns>The task that represents the asynchronous send operation. The TResult
        /// parameter contains the response from the server.</returns>
        /// <exception cref="Dropbox.Api.ApiException{TError}">Thrown if there is an error
        /// processing the request; This will contain a <see cref="RestoreError"/>.</exception>
        public t.Task<FileMetadata> RestoreAsync(RestoreArg restoreArg)
        {
            return this.Transport.SendRpcRequestAsync<RestoreArg, FileMetadata, RestoreError>(restoreArg, "api", "/files/restore", Dropbox.Api.Files.RestoreArg.Encoder, Dropbox.Api.Files.FileMetadata.Decoder, Dropbox.Api.Files.RestoreError.Decoder);
        }

        /// <summary>
        /// <para>Begins an asynchronous send to the restore route.</para>
        /// </summary>
        /// <param name="restoreArg">The request parameters.</param>
        /// <param name="callback">The method to be called when the asynchronous send is
        /// completed.</param>
        /// <param name="state">A user provided object that distinguished this send from other
        /// send requests.</param>
        /// <returns>An object that represents the asynchronous send request.</returns>
        public sys.IAsyncResult BeginRestore(RestoreArg restoreArg, sys.AsyncCallback callback, object state = null)
        {
            var task = this.RestoreAsync(restoreArg);

            return enc.Util.ToApm(task, callback, state);
        }

        /// <summary>
        /// <para>Restore a file to a specific revision</para>
        /// </summary>
        /// <param name="path">The path to the file you want to restore.</param>
        /// <param name="rev">The revision to restore for the file.</param>
        /// <returns>The task that represents the asynchronous send operation. The TResult
        /// parameter contains the response from the server.</returns>
        /// <exception cref="Dropbox.Api.ApiException{TError}">Thrown if there is an error
        /// processing the request; This will contain a <see cref="RestoreError"/>.</exception>
        public t.Task<FileMetadata> RestoreAsync(string path,
                                                 string rev)
        {
            var restoreArg = new RestoreArg(path,
                                            rev);

            return this.RestoreAsync(restoreArg);
        }

        /// <summary>
        /// <para>Begins an asynchronous send to the restore route.</para>
        /// </summary>
        /// <param name="path">The path to the file you want to restore.</param>
        /// <param name="rev">The revision to restore for the file.</param>
        /// <param name="callback">The method to be called when the asynchronous send is
        /// completed.</param>
        /// <param name="callbackState">A user provided object that distinguished this send
        /// from other send requests.</param>
        /// <returns>An object that represents the asynchronous send request.</returns>
        public sys.IAsyncResult BeginRestore(string path,
                                             string rev,
                                             sys.AsyncCallback callback,
                                             object callbackState = null)
        {
            var restoreArg = new RestoreArg(path,
                                            rev);

            return this.BeginRestore(restoreArg, callback, callbackState);
        }

        /// <summary>
        /// <para>Waits for the pending asynchronous send to the restore route to
        /// complete</para>
        /// </summary>
        /// <param name="asyncResult">The reference to the pending asynchronous send
        /// request</param>
        /// <returns>The response to the send request</returns>
        /// <exception cref="Dropbox.Api.ApiException{TError}">Thrown if there is an error
        /// processing the request; This will contain a <see cref="RestoreError"/>.</exception>
        public FileMetadata EndRestore(sys.IAsyncResult asyncResult)
        {
            var task = asyncResult as t.Task<FileMetadata>;
            if (task == null)
            {
                throw new sys.InvalidOperationException();
            }

            return task.Result;
        }

        /// <summary>
        /// <para>Save a specified URL into a file in user's Dropbox. If the given path already
        /// exists, the file will be renamed to avoid the conflict (e.g. myfile
        /// (1).txt).</para>
        /// </summary>
        /// <param name="saveUrlArg">The request parameters</param>
        /// <returns>The task that represents the asynchronous send operation. The TResult
        /// parameter contains the response from the server.</returns>
        /// <exception cref="Dropbox.Api.ApiException{TError}">Thrown if there is an error
        /// processing the request; This will contain a <see cref="SaveUrlError"/>.</exception>
        public t.Task<SaveUrlResult> SaveUrlAsync(SaveUrlArg saveUrlArg)
        {
            return this.Transport.SendRpcRequestAsync<SaveUrlArg, SaveUrlResult, SaveUrlError>(saveUrlArg, "api", "/files/save_url", Dropbox.Api.Files.SaveUrlArg.Encoder, Dropbox.Api.Files.SaveUrlResult.Decoder, Dropbox.Api.Files.SaveUrlError.Decoder);
        }

        /// <summary>
        /// <para>Begins an asynchronous send to the save url route.</para>
        /// </summary>
        /// <param name="saveUrlArg">The request parameters.</param>
        /// <param name="callback">The method to be called when the asynchronous send is
        /// completed.</param>
        /// <param name="state">A user provided object that distinguished this send from other
        /// send requests.</param>
        /// <returns>An object that represents the asynchronous send request.</returns>
        public sys.IAsyncResult BeginSaveUrl(SaveUrlArg saveUrlArg, sys.AsyncCallback callback, object state = null)
        {
            var task = this.SaveUrlAsync(saveUrlArg);

            return enc.Util.ToApm(task, callback, state);
        }

        /// <summary>
        /// <para>Save a specified URL into a file in user's Dropbox. If the given path already
        /// exists, the file will be renamed to avoid the conflict (e.g. myfile
        /// (1).txt).</para>
        /// </summary>
        /// <param name="path">The path in Dropbox where the URL will be saved to.</param>
        /// <param name="url">The URL to be saved.</param>
        /// <returns>The task that represents the asynchronous send operation. The TResult
        /// parameter contains the response from the server.</returns>
        /// <exception cref="Dropbox.Api.ApiException{TError}">Thrown if there is an error
        /// processing the request; This will contain a <see cref="SaveUrlError"/>.</exception>
        public t.Task<SaveUrlResult> SaveUrlAsync(string path,
                                                  string url)
        {
            var saveUrlArg = new SaveUrlArg(path,
                                            url);

            return this.SaveUrlAsync(saveUrlArg);
        }

        /// <summary>
        /// <para>Begins an asynchronous send to the save url route.</para>
        /// </summary>
        /// <param name="path">The path in Dropbox where the URL will be saved to.</param>
        /// <param name="url">The URL to be saved.</param>
        /// <param name="callback">The method to be called when the asynchronous send is
        /// completed.</param>
        /// <param name="callbackState">A user provided object that distinguished this send
        /// from other send requests.</param>
        /// <returns>An object that represents the asynchronous send request.</returns>
        public sys.IAsyncResult BeginSaveUrl(string path,
                                             string url,
                                             sys.AsyncCallback callback,
                                             object callbackState = null)
        {
            var saveUrlArg = new SaveUrlArg(path,
                                            url);

            return this.BeginSaveUrl(saveUrlArg, callback, callbackState);
        }

        /// <summary>
        /// <para>Waits for the pending asynchronous send to the save url route to
        /// complete</para>
        /// </summary>
        /// <param name="asyncResult">The reference to the pending asynchronous send
        /// request</param>
        /// <returns>The response to the send request</returns>
        /// <exception cref="Dropbox.Api.ApiException{TError}">Thrown if there is an error
        /// processing the request; This will contain a <see cref="SaveUrlError"/>.</exception>
        public SaveUrlResult EndSaveUrl(sys.IAsyncResult asyncResult)
        {
            var task = asyncResult as t.Task<SaveUrlResult>;
            if (task == null)
            {
                throw new sys.InvalidOperationException();
            }

            return task.Result;
        }

        /// <summary>
        /// <para>Check the status of a <see
        /// cref="Dropbox.Api.Files.Routes.FilesRoutes.SaveUrlAsync" /> job.</para>
        /// </summary>
        /// <param name="pollArg">The request parameters</param>
        /// <returns>The task that represents the asynchronous send operation. The TResult
        /// parameter contains the response from the server.</returns>
        /// <exception cref="Dropbox.Api.ApiException{TError}">Thrown if there is an error
        /// processing the request; This will contain a <see
        /// cref="Dropbox.Api.Async.PollError"/>.</exception>
        public t.Task<SaveUrlJobStatus> SaveUrlCheckJobStatusAsync(Dropbox.Api.Async.PollArg pollArg)
        {
            return this.Transport.SendRpcRequestAsync<Dropbox.Api.Async.PollArg, SaveUrlJobStatus, Dropbox.Api.Async.PollError>(pollArg, "api", "/files/save_url/check_job_status", Dropbox.Api.Async.PollArg.Encoder, Dropbox.Api.Files.SaveUrlJobStatus.Decoder, Dropbox.Api.Async.PollError.Decoder);
        }

        /// <summary>
        /// <para>Begins an asynchronous send to the save url check job status route.</para>
        /// </summary>
        /// <param name="pollArg">The request parameters.</param>
        /// <param name="callback">The method to be called when the asynchronous send is
        /// completed.</param>
        /// <param name="state">A user provided object that distinguished this send from other
        /// send requests.</param>
        /// <returns>An object that represents the asynchronous send request.</returns>
        public sys.IAsyncResult BeginSaveUrlCheckJobStatus(Dropbox.Api.Async.PollArg pollArg, sys.AsyncCallback callback, object state = null)
        {
            var task = this.SaveUrlCheckJobStatusAsync(pollArg);

            return enc.Util.ToApm(task, callback, state);
        }

        /// <summary>
        /// <para>Check the status of a <see
        /// cref="Dropbox.Api.Files.Routes.FilesRoutes.SaveUrlAsync" /> job.</para>
        /// </summary>
        /// <param name="asyncJobId">Id of the asynchronous job. This is the value of a
        /// response returned from the method that launched the job.</param>
        /// <returns>The task that represents the asynchronous send operation. The TResult
        /// parameter contains the response from the server.</returns>
        /// <exception cref="Dropbox.Api.ApiException{TError}">Thrown if there is an error
        /// processing the request; This will contain a <see
        /// cref="Dropbox.Api.Async.PollError"/>.</exception>
        public t.Task<SaveUrlJobStatus> SaveUrlCheckJobStatusAsync(string asyncJobId)
        {
            var pollArg = new Dropbox.Api.Async.PollArg(asyncJobId);

            return this.SaveUrlCheckJobStatusAsync(pollArg);
        }

        /// <summary>
        /// <para>Begins an asynchronous send to the save url check job status route.</para>
        /// </summary>
        /// <param name="asyncJobId">Id of the asynchronous job. This is the value of a
        /// response returned from the method that launched the job.</param>
        /// <param name="callback">The method to be called when the asynchronous send is
        /// completed.</param>
        /// <param name="callbackState">A user provided object that distinguished this send
        /// from other send requests.</param>
        /// <returns>An object that represents the asynchronous send request.</returns>
        public sys.IAsyncResult BeginSaveUrlCheckJobStatus(string asyncJobId,
                                                           sys.AsyncCallback callback,
                                                           object callbackState = null)
        {
            var pollArg = new Dropbox.Api.Async.PollArg(asyncJobId);

            return this.BeginSaveUrlCheckJobStatus(pollArg, callback, callbackState);
        }

        /// <summary>
        /// <para>Waits for the pending asynchronous send to the save url check job status
        /// route to complete</para>
        /// </summary>
        /// <param name="asyncResult">The reference to the pending asynchronous send
        /// request</param>
        /// <returns>The response to the send request</returns>
        /// <exception cref="Dropbox.Api.ApiException{TError}">Thrown if there is an error
        /// processing the request; This will contain a <see
        /// cref="Dropbox.Api.Async.PollError"/>.</exception>
        public SaveUrlJobStatus EndSaveUrlCheckJobStatus(sys.IAsyncResult asyncResult)
        {
            var task = asyncResult as t.Task<SaveUrlJobStatus>;
            if (task == null)
            {
                throw new sys.InvalidOperationException();
            }

            return task.Result;
        }

        /// <summary>
        /// <para>Searches for files and folders.</para>
        /// <para>Note: Recent changes may not immediately be reflected in search results due
        /// to a short delay in indexing.</para>
        /// </summary>
        /// <param name="searchArg">The request parameters</param>
        /// <returns>The task that represents the asynchronous send operation. The TResult
        /// parameter contains the response from the server.</returns>
        /// <exception cref="Dropbox.Api.ApiException{TError}">Thrown if there is an error
        /// processing the request; This will contain a <see cref="SearchError"/>.</exception>
        public t.Task<SearchResult> SearchAsync(SearchArg searchArg)
        {
            return this.Transport.SendRpcRequestAsync<SearchArg, SearchResult, SearchError>(searchArg, "api", "/files/search", Dropbox.Api.Files.SearchArg.Encoder, Dropbox.Api.Files.SearchResult.Decoder, Dropbox.Api.Files.SearchError.Decoder);
        }

        /// <summary>
        /// <para>Begins an asynchronous send to the search route.</para>
        /// </summary>
        /// <param name="searchArg">The request parameters.</param>
        /// <param name="callback">The method to be called when the asynchronous send is
        /// completed.</param>
        /// <param name="state">A user provided object that distinguished this send from other
        /// send requests.</param>
        /// <returns>An object that represents the asynchronous send request.</returns>
        public sys.IAsyncResult BeginSearch(SearchArg searchArg, sys.AsyncCallback callback, object state = null)
        {
            var task = this.SearchAsync(searchArg);

            return enc.Util.ToApm(task, callback, state);
        }

        /// <summary>
        /// <para>Searches for files and folders.</para>
        /// <para>Note: Recent changes may not immediately be reflected in search results due
        /// to a short delay in indexing.</para>
        /// </summary>
        /// <param name="path">The path in the user's Dropbox to search. Should probably be a
        /// folder.</param>
        /// <param name="query">The string to search for. The search string is split on spaces
        /// into multiple tokens. For file name searching, the last token is used for prefix
        /// matching (i.e. "bat c" matches "bat cave" but not "batman car").</param>
        /// <param name="start">The starting index within the search results (used for
        /// paging).</param>
        /// <param name="maxResults">The maximum number of search results to return.</param>
        /// <param name="mode">The search mode (filename, filename_and_content, or
        /// deleted_filename). Note that searching file content is only available for Dropbox
        /// Business accounts.</param>
        /// <returns>The task that represents the asynchronous send operation. The TResult
        /// parameter contains the response from the server.</returns>
        /// <exception cref="Dropbox.Api.ApiException{TError}">Thrown if there is an error
        /// processing the request; This will contain a <see cref="SearchError"/>.</exception>
        public t.Task<SearchResult> SearchAsync(string path,
                                                string query,
                                                ulong start = 0,
                                                ulong maxResults = 100,
                                                SearchMode mode = null)
        {
            var searchArg = new SearchArg(path,
                                          query,
                                          start,
                                          maxResults,
                                          mode);

            return this.SearchAsync(searchArg);
        }

        /// <summary>
        /// <para>Begins an asynchronous send to the search route.</para>
        /// </summary>
        /// <param name="path">The path in the user's Dropbox to search. Should probably be a
        /// folder.</param>
        /// <param name="query">The string to search for. The search string is split on spaces
        /// into multiple tokens. For file name searching, the last token is used for prefix
        /// matching (i.e. "bat c" matches "bat cave" but not "batman car").</param>
        /// <param name="start">The starting index within the search results (used for
        /// paging).</param>
        /// <param name="maxResults">The maximum number of search results to return.</param>
        /// <param name="mode">The search mode (filename, filename_and_content, or
        /// deleted_filename). Note that searching file content is only available for Dropbox
        /// Business accounts.</param>
        /// <param name="callback">The method to be called when the asynchronous send is
        /// completed.</param>
        /// <param name="callbackState">A user provided object that distinguished this send
        /// from other send requests.</param>
        /// <returns>An object that represents the asynchronous send request.</returns>
        public sys.IAsyncResult BeginSearch(string path,
                                            string query,
                                            ulong start = 0,
                                            ulong maxResults = 100,
                                            SearchMode mode = null,
                                            sys.AsyncCallback callback = null,
                                            object callbackState = null)
        {
            var searchArg = new SearchArg(path,
                                          query,
                                          start,
                                          maxResults,
                                          mode);

            return this.BeginSearch(searchArg, callback, callbackState);
        }

        /// <summary>
        /// <para>Waits for the pending asynchronous send to the search route to
        /// complete</para>
        /// </summary>
        /// <param name="asyncResult">The reference to the pending asynchronous send
        /// request</param>
        /// <returns>The response to the send request</returns>
        /// <exception cref="Dropbox.Api.ApiException{TError}">Thrown if there is an error
        /// processing the request; This will contain a <see cref="SearchError"/>.</exception>
        public SearchResult EndSearch(sys.IAsyncResult asyncResult)
        {
            var task = asyncResult as t.Task<SearchResult>;
            if (task == null)
            {
                throw new sys.InvalidOperationException();
            }

            return task.Result;
        }

        /// <summary>
        /// <para>Create a new file with the contents provided in the request.</para>
        /// <para>Do not use this to upload a file larger than 150 MB. Instead, create an
        /// upload session with <see
        /// cref="Dropbox.Api.Files.Routes.FilesRoutes.UploadSessionStartAsync" />.</para>
        /// </summary>
        /// <param name="commitInfo">The request parameters</param>
        /// <param name="body">The content to upload.</param>
        /// <returns>The task that represents the asynchronous send operation. The TResult
        /// parameter contains the response from the server.</returns>
        /// <exception cref="Dropbox.Api.ApiException{TError}">Thrown if there is an error
        /// processing the request; This will contain a <see cref="UploadError"/>.</exception>
        public t.Task<FileMetadata> UploadAsync(CommitInfo commitInfo, io.Stream body)
        {
            return this.Transport.SendUploadRequestAsync<CommitInfo, FileMetadata, UploadError>(commitInfo, body, "content", "/files/upload", Dropbox.Api.Files.CommitInfo.Encoder, Dropbox.Api.Files.FileMetadata.Decoder, Dropbox.Api.Files.UploadError.Decoder);
        }

        /// <summary>
        /// <para>Begins an asynchronous send to the upload route.</para>
        /// </summary>
        /// <param name="commitInfo">The request parameters.</param>
        /// <param name="body">The content to upload.</param>
        /// <param name="callback">The method to be called when the asynchronous send is
        /// completed.</param>
        /// <param name="state">A user provided object that distinguished this send from other
        /// send requests.</param>
        /// <returns>An object that represents the asynchronous send request.</returns>
        public sys.IAsyncResult BeginUpload(CommitInfo commitInfo, io.Stream body, sys.AsyncCallback callback, object state = null)
        {
            var task = this.UploadAsync(commitInfo, body);

            return enc.Util.ToApm(task, callback, state);
        }

        /// <summary>
        /// <para>Create a new file with the contents provided in the request.</para>
        /// <para>Do not use this to upload a file larger than 150 MB. Instead, create an
        /// upload session with <see
        /// cref="Dropbox.Api.Files.Routes.FilesRoutes.UploadSessionStartAsync" />.</para>
        /// </summary>
        /// <param name="path">Path in the user's Dropbox to save the file.</param>
        /// <param name="mode">Selects what to do if the file already exists.</param>
        /// <param name="autorename">If there's a conflict, as determined by <paramref
        /// name="mode" />, have the Dropbox server try to autorename the file to avoid
        /// conflict.</param>
        /// <param name="clientModified">The value to store as the <paramref
        /// name="clientModified" /> timestamp. Dropbox automatically records the time at which
        /// the file was written to the Dropbox servers. It can also record an additional
        /// timestamp, provided by Dropbox desktop clients, mobile clients, and API apps of
        /// when the file was actually created or modified.</param>
        /// <param name="mute">Normally, users are made aware of any file modifications in
        /// their Dropbox account via notifications in the client software. If <c>true</c>,
        /// this tells the clients that this modification shouldn't result in a user
        /// notification.</param>
        /// <param name="body">The document to upload</param>
        /// <returns>The task that represents the asynchronous send operation. The TResult
        /// parameter contains the response from the server.</returns>
        /// <exception cref="Dropbox.Api.ApiException{TError}">Thrown if there is an error
        /// processing the request; This will contain a <see cref="UploadError"/>.</exception>
        public t.Task<FileMetadata> UploadAsync(string path,
                                                WriteMode mode = null,
                                                bool autorename = false,
                                                sys.DateTime? clientModified = null,
                                                bool mute = false,
                                                io.Stream body = null)
        {
            var commitInfo = new CommitInfo(path,
                                            mode,
                                            autorename,
                                            clientModified,
                                            mute);

            return this.UploadAsync(commitInfo, body);
        }

        /// <summary>
        /// <para>Begins an asynchronous send to the upload route.</para>
        /// </summary>
        /// <param name="path">Path in the user's Dropbox to save the file.</param>
        /// <param name="mode">Selects what to do if the file already exists.</param>
        /// <param name="autorename">If there's a conflict, as determined by <paramref
        /// name="mode" />, have the Dropbox server try to autorename the file to avoid
        /// conflict.</param>
        /// <param name="clientModified">The value to store as the <paramref
        /// name="clientModified" /> timestamp. Dropbox automatically records the time at which
        /// the file was written to the Dropbox servers. It can also record an additional
        /// timestamp, provided by Dropbox desktop clients, mobile clients, and API apps of
        /// when the file was actually created or modified.</param>
        /// <param name="mute">Normally, users are made aware of any file modifications in
        /// their Dropbox account via notifications in the client software. If <c>true</c>,
        /// this tells the clients that this modification shouldn't result in a user
        /// notification.</param>
        /// <param name="body">The document to upload</param>
        /// <param name="callback">The method to be called when the asynchronous send is
        /// completed.</param>
        /// <param name="callbackState">A user provided object that distinguished this send
        /// from other send requests.</param>
        /// <returns>An object that represents the asynchronous send request.</returns>
        public sys.IAsyncResult BeginUpload(string path,
                                            WriteMode mode = null,
                                            bool autorename = false,
                                            sys.DateTime? clientModified = null,
                                            bool mute = false,
                                            io.Stream body = null,
                                            sys.AsyncCallback callback = null,
                                            object callbackState = null)
        {
            var commitInfo = new CommitInfo(path,
                                            mode,
                                            autorename,
                                            clientModified,
                                            mute);

            return this.BeginUpload(commitInfo, body, callback, callbackState);
        }

        /// <summary>
        /// <para>Waits for the pending asynchronous send to the upload route to
        /// complete</para>
        /// </summary>
        /// <param name="asyncResult">The reference to the pending asynchronous send
        /// request</param>
        /// <returns>The response to the send request</returns>
        /// <exception cref="Dropbox.Api.ApiException{TError}">Thrown if there is an error
        /// processing the request; This will contain a <see cref="UploadError"/>.</exception>
        public FileMetadata EndUpload(sys.IAsyncResult asyncResult)
        {
            var task = asyncResult as t.Task<FileMetadata>;
            if (task == null)
            {
                throw new sys.InvalidOperationException();
            }

            return task.Result;
        }

        /// <summary>
        /// <para>Append more data to an upload session.</para>
        /// <para>A single request should not upload more than 150 MB of file contents.</para>
        /// </summary>
        /// <param name="uploadSessionCursor">The request parameters</param>
        /// <param name="body">The content to upload.</param>
        /// <returns>The task that represents the asynchronous send operation.</returns>
        /// <exception cref="Dropbox.Api.ApiException{TError}">Thrown if there is an error
        /// processing the request; This will contain a <see
        /// cref="UploadSessionLookupError"/>.</exception>
        [sys.Obsolete("This function is deprecated, please use UploadSessionAppendV2Async instead.")]
        public t.Task UploadSessionAppendAsync(UploadSessionCursor uploadSessionCursor, io.Stream body)
        {
            return this.Transport.SendUploadRequestAsync<UploadSessionCursor, enc.Empty, UploadSessionLookupError>(uploadSessionCursor, body, "content", "/files/upload_session/append", Dropbox.Api.Files.UploadSessionCursor.Encoder, enc.EmptyDecoder.Instance, Dropbox.Api.Files.UploadSessionLookupError.Decoder);
        }

        /// <summary>
        /// <para>Begins an asynchronous send to the upload session append route.</para>
        /// </summary>
        /// <param name="uploadSessionCursor">The request parameters.</param>
        /// <param name="body">The content to upload.</param>
        /// <param name="callback">The method to be called when the asynchronous send is
        /// completed.</param>
        /// <param name="state">A user provided object that distinguished this send from other
        /// send requests.</param>
        /// <returns>An object that represents the asynchronous send request.</returns>
        [sys.Obsolete("This function is deprecated, please use BeginUploadSessionAppendV2 instead.")]
        public sys.IAsyncResult BeginUploadSessionAppend(UploadSessionCursor uploadSessionCursor, io.Stream body, sys.AsyncCallback callback, object state = null)
        {
            var task = this.UploadSessionAppendAsync(uploadSessionCursor, body);

            return enc.Util.ToApm(task, callback, state);
        }

        /// <summary>
        /// <para>Append more data to an upload session.</para>
        /// <para>A single request should not upload more than 150 MB of file contents.</para>
        /// </summary>
        /// <param name="sessionId">The upload session ID (returned by <see
        /// cref="Dropbox.Api.Files.Routes.FilesRoutes.UploadSessionStartAsync" />).</param>
        /// <param name="offset">The amount of data that has been uploaded so far. We use this
        /// to make sure upload data isn't lost or duplicated in the event of a network
        /// error.</param>
        /// <param name="body">The document to upload</param>
        /// <returns>The task that represents the asynchronous send operation.</returns>
        /// <exception cref="Dropbox.Api.ApiException{TError}">Thrown if there is an error
        /// processing the request; This will contain a <see
        /// cref="UploadSessionLookupError"/>.</exception>
        [sys.Obsolete("This function is deprecated, please use UploadSessionAppendV2Async instead.")]
        public t.Task UploadSessionAppendAsync(string sessionId,
                                               ulong offset,
                                               io.Stream body)
        {
            var uploadSessionCursor = new UploadSessionCursor(sessionId,
                                                              offset);

            return this.UploadSessionAppendAsync(uploadSessionCursor, body);
        }

        /// <summary>
        /// <para>Begins an asynchronous send to the upload session append route.</para>
        /// </summary>
        /// <param name="sessionId">The upload session ID (returned by <see
        /// cref="Dropbox.Api.Files.Routes.FilesRoutes.UploadSessionStartAsync" />).</param>
        /// <param name="offset">The amount of data that has been uploaded so far. We use this
        /// to make sure upload data isn't lost or duplicated in the event of a network
        /// error.</param>
        /// <param name="body">The document to upload</param>
        /// <param name="callback">The method to be called when the asynchronous send is
        /// completed.</param>
        /// <param name="callbackState">A user provided object that distinguished this send
        /// from other send requests.</param>
        /// <returns>An object that represents the asynchronous send request.</returns>
        [sys.Obsolete("This function is deprecated, please use BeginUploadSessionAppendV2 instead.")]
        public sys.IAsyncResult BeginUploadSessionAppend(string sessionId,
                                                         ulong offset,
                                                         io.Stream body,
                                                         sys.AsyncCallback callback,
                                                         object callbackState = null)
        {
            var uploadSessionCursor = new UploadSessionCursor(sessionId,
                                                              offset);

            return this.BeginUploadSessionAppend(uploadSessionCursor, body, callback, callbackState);
        }

        /// <summary>
        /// <para>Waits for the pending asynchronous send to the upload session append route to
        /// complete</para>
        /// </summary>
        /// <param name="asyncResult">The reference to the pending asynchronous send
        /// request</param>
        /// <exception cref="Dropbox.Api.ApiException{TError}">Thrown if there is an error
        /// processing the request; This will contain a <see
        /// cref="UploadSessionLookupError"/>.</exception>
        [sys.Obsolete("This function is deprecated, please use EndUploadSessionAppendV2 instead.")]
        public void EndUploadSessionAppend(sys.IAsyncResult asyncResult)
        {
            var task = asyncResult as t.Task;
            if (task == null)
            {
                throw new sys.InvalidOperationException();
            }
        }

        /// <summary>
        /// <para>Append more data to an upload session.</para>
        /// <para>When the parameter close is set, this call will close the session.</para>
        /// <para>A single request should not upload more than 150 MB of file contents.</para>
        /// </summary>
        /// <param name="uploadSessionAppendArg">The request parameters</param>
        /// <param name="body">The content to upload.</param>
        /// <returns>The task that represents the asynchronous send operation.</returns>
        /// <exception cref="Dropbox.Api.ApiException{TError}">Thrown if there is an error
        /// processing the request; This will contain a <see
        /// cref="UploadSessionLookupError"/>.</exception>
        public t.Task UploadSessionAppendV2Async(UploadSessionAppendArg uploadSessionAppendArg, io.Stream body)
        {
            return this.Transport.SendUploadRequestAsync<UploadSessionAppendArg, enc.Empty, UploadSessionLookupError>(uploadSessionAppendArg, body, "content", "/files/upload_session/append_v2", Dropbox.Api.Files.UploadSessionAppendArg.Encoder, enc.EmptyDecoder.Instance, Dropbox.Api.Files.UploadSessionLookupError.Decoder);
        }

        /// <summary>
        /// <para>Begins an asynchronous send to the upload session append v2 route.</para>
        /// </summary>
        /// <param name="uploadSessionAppendArg">The request parameters.</param>
        /// <param name="body">The content to upload.</param>
        /// <param name="callback">The method to be called when the asynchronous send is
        /// completed.</param>
        /// <param name="state">A user provided object that distinguished this send from other
        /// send requests.</param>
        /// <returns>An object that represents the asynchronous send request.</returns>
        public sys.IAsyncResult BeginUploadSessionAppendV2(UploadSessionAppendArg uploadSessionAppendArg, io.Stream body, sys.AsyncCallback callback, object state = null)
        {
            var task = this.UploadSessionAppendV2Async(uploadSessionAppendArg, body);

            return enc.Util.ToApm(task, callback, state);
        }

        /// <summary>
        /// <para>Append more data to an upload session.</para>
        /// <para>When the parameter close is set, this call will close the session.</para>
        /// <para>A single request should not upload more than 150 MB of file contents.</para>
        /// </summary>
        /// <param name="cursor">Contains the upload session ID and the offset.</param>
        /// <param name="close">If true, the current session will be closed, at which point you
        /// won't be able to call <see
        /// cref="Dropbox.Api.Files.Routes.FilesRoutes.UploadSessionAppendV2Async" /> anymore
        /// with the current session.</param>
        /// <param name="body">The document to upload</param>
        /// <returns>The task that represents the asynchronous send operation.</returns>
        /// <exception cref="Dropbox.Api.ApiException{TError}">Thrown if there is an error
        /// processing the request; This will contain a <see
        /// cref="UploadSessionLookupError"/>.</exception>
        public t.Task UploadSessionAppendV2Async(UploadSessionCursor cursor,
                                                 bool close = false,
                                                 io.Stream body = null)
        {
            var uploadSessionAppendArg = new UploadSessionAppendArg(cursor,
                                                                    close);

            return this.UploadSessionAppendV2Async(uploadSessionAppendArg, body);
        }

        /// <summary>
        /// <para>Begins an asynchronous send to the upload session append v2 route.</para>
        /// </summary>
        /// <param name="cursor">Contains the upload session ID and the offset.</param>
        /// <param name="close">If true, the current session will be closed, at which point you
        /// won't be able to call <see
        /// cref="Dropbox.Api.Files.Routes.FilesRoutes.UploadSessionAppendV2Async" /> anymore
        /// with the current session.</param>
        /// <param name="body">The document to upload</param>
        /// <param name="callback">The method to be called when the asynchronous send is
        /// completed.</param>
        /// <param name="callbackState">A user provided object that distinguished this send
        /// from other send requests.</param>
        /// <returns>An object that represents the asynchronous send request.</returns>
        public sys.IAsyncResult BeginUploadSessionAppendV2(UploadSessionCursor cursor,
                                                           bool close = false,
                                                           io.Stream body = null,
                                                           sys.AsyncCallback callback = null,
                                                           object callbackState = null)
        {
            var uploadSessionAppendArg = new UploadSessionAppendArg(cursor,
                                                                    close);

            return this.BeginUploadSessionAppendV2(uploadSessionAppendArg, body, callback, callbackState);
        }

        /// <summary>
        /// <para>Waits for the pending asynchronous send to the upload session append v2 route
        /// to complete</para>
        /// </summary>
        /// <param name="asyncResult">The reference to the pending asynchronous send
        /// request</param>
        /// <exception cref="Dropbox.Api.ApiException{TError}">Thrown if there is an error
        /// processing the request; This will contain a <see
        /// cref="UploadSessionLookupError"/>.</exception>
        public void EndUploadSessionAppendV2(sys.IAsyncResult asyncResult)
        {
            var task = asyncResult as t.Task;
            if (task == null)
            {
                throw new sys.InvalidOperationException();
            }
        }

        /// <summary>
        /// <para>Finish an upload session and save the uploaded data to the given file
        /// path.</para>
        /// <para>A single request should not upload more than 150 MB of file contents.</para>
        /// </summary>
        /// <param name="uploadSessionFinishArg">The request parameters</param>
        /// <param name="body">The content to upload.</param>
        /// <returns>The task that represents the asynchronous send operation. The TResult
        /// parameter contains the response from the server.</returns>
        /// <exception cref="Dropbox.Api.ApiException{TError}">Thrown if there is an error
        /// processing the request; This will contain a <see
        /// cref="UploadSessionFinishError"/>.</exception>
        public t.Task<FileMetadata> UploadSessionFinishAsync(UploadSessionFinishArg uploadSessionFinishArg, io.Stream body)
        {
            return this.Transport.SendUploadRequestAsync<UploadSessionFinishArg, FileMetadata, UploadSessionFinishError>(uploadSessionFinishArg, body, "content", "/files/upload_session/finish", Dropbox.Api.Files.UploadSessionFinishArg.Encoder, Dropbox.Api.Files.FileMetadata.Decoder, Dropbox.Api.Files.UploadSessionFinishError.Decoder);
        }

        /// <summary>
        /// <para>Begins an asynchronous send to the upload session finish route.</para>
        /// </summary>
        /// <param name="uploadSessionFinishArg">The request parameters.</param>
        /// <param name="body">The content to upload.</param>
        /// <param name="callback">The method to be called when the asynchronous send is
        /// completed.</param>
        /// <param name="state">A user provided object that distinguished this send from other
        /// send requests.</param>
        /// <returns>An object that represents the asynchronous send request.</returns>
        public sys.IAsyncResult BeginUploadSessionFinish(UploadSessionFinishArg uploadSessionFinishArg, io.Stream body, sys.AsyncCallback callback, object state = null)
        {
            var task = this.UploadSessionFinishAsync(uploadSessionFinishArg, body);

            return enc.Util.ToApm(task, callback, state);
        }

        /// <summary>
        /// <para>Finish an upload session and save the uploaded data to the given file
        /// path.</para>
        /// <para>A single request should not upload more than 150 MB of file contents.</para>
        /// </summary>
        /// <param name="cursor">Contains the upload session ID and the offset.</param>
        /// <param name="commit">Contains the path and other optional modifiers for the
        /// commit.</param>
        /// <param name="body">The document to upload</param>
        /// <returns>The task that represents the asynchronous send operation. The TResult
        /// parameter contains the response from the server.</returns>
        /// <exception cref="Dropbox.Api.ApiException{TError}">Thrown if there is an error
        /// processing the request; This will contain a <see
        /// cref="UploadSessionFinishError"/>.</exception>
        public t.Task<FileMetadata> UploadSessionFinishAsync(UploadSessionCursor cursor,
                                                             CommitInfo commit,
                                                             io.Stream body)
        {
            var uploadSessionFinishArg = new UploadSessionFinishArg(cursor,
                                                                    commit);

            return this.UploadSessionFinishAsync(uploadSessionFinishArg, body);
        }

        /// <summary>
        /// <para>Begins an asynchronous send to the upload session finish route.</para>
        /// </summary>
        /// <param name="cursor">Contains the upload session ID and the offset.</param>
        /// <param name="commit">Contains the path and other optional modifiers for the
        /// commit.</param>
        /// <param name="body">The document to upload</param>
        /// <param name="callback">The method to be called when the asynchronous send is
        /// completed.</param>
        /// <param name="callbackState">A user provided object that distinguished this send
        /// from other send requests.</param>
        /// <returns>An object that represents the asynchronous send request.</returns>
        public sys.IAsyncResult BeginUploadSessionFinish(UploadSessionCursor cursor,
                                                         CommitInfo commit,
                                                         io.Stream body,
                                                         sys.AsyncCallback callback,
                                                         object callbackState = null)
        {
            var uploadSessionFinishArg = new UploadSessionFinishArg(cursor,
                                                                    commit);

            return this.BeginUploadSessionFinish(uploadSessionFinishArg, body, callback, callbackState);
        }

        /// <summary>
        /// <para>Waits for the pending asynchronous send to the upload session finish route to
        /// complete</para>
        /// </summary>
        /// <param name="asyncResult">The reference to the pending asynchronous send
        /// request</param>
        /// <returns>The response to the send request</returns>
        /// <exception cref="Dropbox.Api.ApiException{TError}">Thrown if there is an error
        /// processing the request; This will contain a <see
        /// cref="UploadSessionFinishError"/>.</exception>
        public FileMetadata EndUploadSessionFinish(sys.IAsyncResult asyncResult)
        {
            var task = asyncResult as t.Task<FileMetadata>;
            if (task == null)
            {
                throw new sys.InvalidOperationException();
            }

            return task.Result;
        }

        /// <summary>
        /// <para>This route helps you commit many files at once into a user's Dropbox. Use
        /// <see cref="Dropbox.Api.Files.Routes.FilesRoutes.UploadSessionStartAsync" /> and
        /// <see cref="Dropbox.Api.Files.Routes.FilesRoutes.UploadSessionAppendV2Async" /> to
        /// upload file contents. We recommend uploading many files in parallel to increase
        /// throughput. Once the file contents have been uploaded, rather than calling <see
        /// cref="Dropbox.Api.Files.Routes.FilesRoutes.UploadSessionFinishAsync" />, use this
        /// route to finish all your upload sessions in a single request.</para>
        /// <para><see cref="Dropbox.Api.Files.UploadSessionStartArg.Close" /> or <see
        /// cref="Dropbox.Api.Files.UploadSessionAppendArg.Close" /> needs to be true for last
        /// <see cref="Dropbox.Api.Files.Routes.FilesRoutes.UploadSessionStartAsync" /> or <see
        /// cref="Dropbox.Api.Files.Routes.FilesRoutes.UploadSessionAppendV2Async" />
        /// call.</para>
        /// <para>This route will return job_id immediately and do the async commit job in
        /// background. We have another route <see
        /// cref="Dropbox.Api.Files.Routes.FilesRoutes.UploadSessionFinishBatchCheckAsync" />
        /// to check the job status.</para>
        /// <para>For the same account, this route should be executed serially. That means you
        /// should not start next job before current job finishes. Also we only allow up to
        /// 1000 entries in a single request</para>
        /// </summary>
        /// <param name="uploadSessionFinishBatchArg">The request parameters</param>
        /// <returns>The task that represents the asynchronous send operation. The TResult
        /// parameter contains the response from the server.</returns>
        public t.Task<Dropbox.Api.Async.LaunchEmptyResult> UploadSessionFinishBatchAsync(UploadSessionFinishBatchArg uploadSessionFinishBatchArg)
        {
            return this.Transport.SendRpcRequestAsync<UploadSessionFinishBatchArg, Dropbox.Api.Async.LaunchEmptyResult, enc.Empty>(uploadSessionFinishBatchArg, "api", "/files/upload_session/finish_batch", Dropbox.Api.Files.UploadSessionFinishBatchArg.Encoder, Dropbox.Api.Async.LaunchEmptyResult.Decoder, enc.EmptyDecoder.Instance);
        }

        /// <summary>
        /// <para>Begins an asynchronous send to the upload session finish batch route.</para>
        /// </summary>
        /// <param name="uploadSessionFinishBatchArg">The request parameters.</param>
        /// <param name="callback">The method to be called when the asynchronous send is
        /// completed.</param>
        /// <param name="state">A user provided object that distinguished this send from other
        /// send requests.</param>
        /// <returns>An object that represents the asynchronous send request.</returns>
        public sys.IAsyncResult BeginUploadSessionFinishBatch(UploadSessionFinishBatchArg uploadSessionFinishBatchArg, sys.AsyncCallback callback, object state = null)
        {
            var task = this.UploadSessionFinishBatchAsync(uploadSessionFinishBatchArg);

            return enc.Util.ToApm(task, callback, state);
        }

        /// <summary>
        /// <para>This route helps you commit many files at once into a user's Dropbox. Use
        /// <see cref="Dropbox.Api.Files.Routes.FilesRoutes.UploadSessionStartAsync" /> and
        /// <see cref="Dropbox.Api.Files.Routes.FilesRoutes.UploadSessionAppendV2Async" /> to
        /// upload file contents. We recommend uploading many files in parallel to increase
        /// throughput. Once the file contents have been uploaded, rather than calling <see
        /// cref="Dropbox.Api.Files.Routes.FilesRoutes.UploadSessionFinishAsync" />, use this
        /// route to finish all your upload sessions in a single request.</para>
        /// <para><see cref="Dropbox.Api.Files.UploadSessionStartArg.Close" /> or <see
        /// cref="Dropbox.Api.Files.UploadSessionAppendArg.Close" /> needs to be true for last
        /// <see cref="Dropbox.Api.Files.Routes.FilesRoutes.UploadSessionStartAsync" /> or <see
        /// cref="Dropbox.Api.Files.Routes.FilesRoutes.UploadSessionAppendV2Async" />
        /// call.</para>
        /// <para>This route will return job_id immediately and do the async commit job in
        /// background. We have another route <see
        /// cref="Dropbox.Api.Files.Routes.FilesRoutes.UploadSessionFinishBatchCheckAsync" />
        /// to check the job status.</para>
        /// <para>For the same account, this route should be executed serially. That means you
        /// should not start next job before current job finishes. Also we only allow up to
        /// 1000 entries in a single request</para>
        /// </summary>
        /// <param name="entries">Commit information for each file in the batch.</param>
        /// <returns>The task that represents the asynchronous send operation. The TResult
        /// parameter contains the response from the server.</returns>
        public t.Task<Dropbox.Api.Async.LaunchEmptyResult> UploadSessionFinishBatchAsync(col.IEnumerable<UploadSessionFinishArg> entries)
        {
            var uploadSessionFinishBatchArg = new UploadSessionFinishBatchArg(entries);

            return this.UploadSessionFinishBatchAsync(uploadSessionFinishBatchArg);
        }

        /// <summary>
        /// <para>Begins an asynchronous send to the upload session finish batch route.</para>
        /// </summary>
        /// <param name="entries">Commit information for each file in the batch.</param>
        /// <param name="callback">The method to be called when the asynchronous send is
        /// completed.</param>
        /// <param name="callbackState">A user provided object that distinguished this send
        /// from other send requests.</param>
        /// <returns>An object that represents the asynchronous send request.</returns>
        public sys.IAsyncResult BeginUploadSessionFinishBatch(col.IEnumerable<UploadSessionFinishArg> entries,
                                                              sys.AsyncCallback callback,
                                                              object callbackState = null)
        {
            var uploadSessionFinishBatchArg = new UploadSessionFinishBatchArg(entries);

            return this.BeginUploadSessionFinishBatch(uploadSessionFinishBatchArg, callback, callbackState);
        }

        /// <summary>
        /// <para>Waits for the pending asynchronous send to the upload session finish batch
        /// route to complete</para>
        /// </summary>
        /// <param name="asyncResult">The reference to the pending asynchronous send
        /// request</param>
        /// <returns>The response to the send request</returns>
        public Dropbox.Api.Async.LaunchEmptyResult EndUploadSessionFinishBatch(sys.IAsyncResult asyncResult)
        {
            var task = asyncResult as t.Task<Dropbox.Api.Async.LaunchEmptyResult>;
            if (task == null)
            {
                throw new sys.InvalidOperationException();
            }

            return task.Result;
        }

        /// <summary>
        /// <para>Returns the status of an asynchronous job for <see
        /// cref="Dropbox.Api.Files.Routes.FilesRoutes.UploadSessionFinishBatchAsync" />. If
        /// success, it returns list of result for each entry</para>
        /// </summary>
        /// <param name="pollArg">The request parameters</param>
        /// <returns>The task that represents the asynchronous send operation. The TResult
        /// parameter contains the response from the server.</returns>
        /// <exception cref="Dropbox.Api.ApiException{TError}">Thrown if there is an error
        /// processing the request; This will contain a <see
        /// cref="Dropbox.Api.Async.PollError"/>.</exception>
        public t.Task<UploadSessionFinishBatchJobStatus> UploadSessionFinishBatchCheckAsync(Dropbox.Api.Async.PollArg pollArg)
        {
            return this.Transport.SendRpcRequestAsync<Dropbox.Api.Async.PollArg, UploadSessionFinishBatchJobStatus, Dropbox.Api.Async.PollError>(pollArg, "api", "/files/upload_session/finish_batch/check", Dropbox.Api.Async.PollArg.Encoder, Dropbox.Api.Files.UploadSessionFinishBatchJobStatus.Decoder, Dropbox.Api.Async.PollError.Decoder);
        }

        /// <summary>
        /// <para>Begins an asynchronous send to the upload session finish batch check
        /// route.</para>
        /// </summary>
        /// <param name="pollArg">The request parameters.</param>
        /// <param name="callback">The method to be called when the asynchronous send is
        /// completed.</param>
        /// <param name="state">A user provided object that distinguished this send from other
        /// send requests.</param>
        /// <returns>An object that represents the asynchronous send request.</returns>
        public sys.IAsyncResult BeginUploadSessionFinishBatchCheck(Dropbox.Api.Async.PollArg pollArg, sys.AsyncCallback callback, object state = null)
        {
            var task = this.UploadSessionFinishBatchCheckAsync(pollArg);

            return enc.Util.ToApm(task, callback, state);
        }

        /// <summary>
        /// <para>Returns the status of an asynchronous job for <see
        /// cref="Dropbox.Api.Files.Routes.FilesRoutes.UploadSessionFinishBatchAsync" />. If
        /// success, it returns list of result for each entry</para>
        /// </summary>
        /// <param name="asyncJobId">Id of the asynchronous job. This is the value of a
        /// response returned from the method that launched the job.</param>
        /// <returns>The task that represents the asynchronous send operation. The TResult
        /// parameter contains the response from the server.</returns>
        /// <exception cref="Dropbox.Api.ApiException{TError}">Thrown if there is an error
        /// processing the request; This will contain a <see
        /// cref="Dropbox.Api.Async.PollError"/>.</exception>
        public t.Task<UploadSessionFinishBatchJobStatus> UploadSessionFinishBatchCheckAsync(string asyncJobId)
        {
            var pollArg = new Dropbox.Api.Async.PollArg(asyncJobId);

            return this.UploadSessionFinishBatchCheckAsync(pollArg);
        }

        /// <summary>
        /// <para>Begins an asynchronous send to the upload session finish batch check
        /// route.</para>
        /// </summary>
        /// <param name="asyncJobId">Id of the asynchronous job. This is the value of a
        /// response returned from the method that launched the job.</param>
        /// <param name="callback">The method to be called when the asynchronous send is
        /// completed.</param>
        /// <param name="callbackState">A user provided object that distinguished this send
        /// from other send requests.</param>
        /// <returns>An object that represents the asynchronous send request.</returns>
        public sys.IAsyncResult BeginUploadSessionFinishBatchCheck(string asyncJobId,
                                                                   sys.AsyncCallback callback,
                                                                   object callbackState = null)
        {
            var pollArg = new Dropbox.Api.Async.PollArg(asyncJobId);

            return this.BeginUploadSessionFinishBatchCheck(pollArg, callback, callbackState);
        }

        /// <summary>
        /// <para>Waits for the pending asynchronous send to the upload session finish batch
        /// check route to complete</para>
        /// </summary>
        /// <param name="asyncResult">The reference to the pending asynchronous send
        /// request</param>
        /// <returns>The response to the send request</returns>
        /// <exception cref="Dropbox.Api.ApiException{TError}">Thrown if there is an error
        /// processing the request; This will contain a <see
        /// cref="Dropbox.Api.Async.PollError"/>.</exception>
        public UploadSessionFinishBatchJobStatus EndUploadSessionFinishBatchCheck(sys.IAsyncResult asyncResult)
        {
            var task = asyncResult as t.Task<UploadSessionFinishBatchJobStatus>;
            if (task == null)
            {
                throw new sys.InvalidOperationException();
            }

            return task.Result;
        }

        /// <summary>
        /// <para>Upload sessions allow you to upload a single file using multiple requests.
        /// This call starts a new upload session with the given data.  You can then use <see
        /// cref="Dropbox.Api.Files.Routes.FilesRoutes.UploadSessionAppendV2Async" /> to add
        /// more data and <see
        /// cref="Dropbox.Api.Files.Routes.FilesRoutes.UploadSessionFinishAsync" /> to save all
        /// the data to a file in Dropbox.</para>
        /// <para>A single request should not upload more than 150 MB of file contents.</para>
        /// </summary>
        /// <param name="uploadSessionStartArg">The request parameters</param>
        /// <param name="body">The content to upload.</param>
        /// <returns>The task that represents the asynchronous send operation. The TResult
        /// parameter contains the response from the server.</returns>
        public t.Task<UploadSessionStartResult> UploadSessionStartAsync(UploadSessionStartArg uploadSessionStartArg, io.Stream body)
        {
            return this.Transport.SendUploadRequestAsync<UploadSessionStartArg, UploadSessionStartResult, enc.Empty>(uploadSessionStartArg, body, "content", "/files/upload_session/start", Dropbox.Api.Files.UploadSessionStartArg.Encoder, Dropbox.Api.Files.UploadSessionStartResult.Decoder, enc.EmptyDecoder.Instance);
        }

        /// <summary>
        /// <para>Begins an asynchronous send to the upload session start route.</para>
        /// </summary>
        /// <param name="uploadSessionStartArg">The request parameters.</param>
        /// <param name="body">The content to upload.</param>
        /// <param name="callback">The method to be called when the asynchronous send is
        /// completed.</param>
        /// <param name="state">A user provided object that distinguished this send from other
        /// send requests.</param>
        /// <returns>An object that represents the asynchronous send request.</returns>
        public sys.IAsyncResult BeginUploadSessionStart(UploadSessionStartArg uploadSessionStartArg, io.Stream body, sys.AsyncCallback callback, object state = null)
        {
            var task = this.UploadSessionStartAsync(uploadSessionStartArg, body);

            return enc.Util.ToApm(task, callback, state);
        }

        /// <summary>
        /// <para>Upload sessions allow you to upload a single file using multiple requests.
        /// This call starts a new upload session with the given data.  You can then use <see
        /// cref="Dropbox.Api.Files.Routes.FilesRoutes.UploadSessionAppendV2Async" /> to add
        /// more data and <see
        /// cref="Dropbox.Api.Files.Routes.FilesRoutes.UploadSessionFinishAsync" /> to save all
        /// the data to a file in Dropbox.</para>
        /// <para>A single request should not upload more than 150 MB of file contents.</para>
        /// </summary>
        /// <param name="close">If true, the current session will be closed, at which point you
        /// won't be able to call <see
        /// cref="Dropbox.Api.Files.Routes.FilesRoutes.UploadSessionAppendV2Async" /> anymore
        /// with the current session.</param>
        /// <param name="body">The document to upload</param>
        /// <returns>The task that represents the asynchronous send operation. The TResult
        /// parameter contains the response from the server.</returns>
        public t.Task<UploadSessionStartResult> UploadSessionStartAsync(bool close = false,
                                                                        io.Stream body = null)
        {
            var uploadSessionStartArg = new UploadSessionStartArg(close);

            return this.UploadSessionStartAsync(uploadSessionStartArg, body);
        }

        /// <summary>
        /// <para>Begins an asynchronous send to the upload session start route.</para>
        /// </summary>
        /// <param name="close">If true, the current session will be closed, at which point you
        /// won't be able to call <see
        /// cref="Dropbox.Api.Files.Routes.FilesRoutes.UploadSessionAppendV2Async" /> anymore
        /// with the current session.</param>
        /// <param name="body">The document to upload</param>
        /// <param name="callback">The method to be called when the asynchronous send is
        /// completed.</param>
        /// <param name="callbackState">A user provided object that distinguished this send
        /// from other send requests.</param>
        /// <returns>An object that represents the asynchronous send request.</returns>
        public sys.IAsyncResult BeginUploadSessionStart(bool close = false,
                                                        io.Stream body = null,
                                                        sys.AsyncCallback callback = null,
                                                        object callbackState = null)
        {
            var uploadSessionStartArg = new UploadSessionStartArg(close);

            return this.BeginUploadSessionStart(uploadSessionStartArg, body, callback, callbackState);
        }

        /// <summary>
        /// <para>Waits for the pending asynchronous send to the upload session start route to
        /// complete</para>
        /// </summary>
        /// <param name="asyncResult">The reference to the pending asynchronous send
        /// request</param>
        /// <returns>The response to the send request</returns>
        public UploadSessionStartResult EndUploadSessionStart(sys.IAsyncResult asyncResult)
        {
            var task = asyncResult as t.Task<UploadSessionStartResult>;
            if (task == null)
            {
                throw new sys.InvalidOperationException();
            }

            return task.Result;
        }
    }
}
